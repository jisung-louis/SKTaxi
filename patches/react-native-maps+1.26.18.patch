diff --git a/node_modules/react-native-maps/android/bin/build.gradle b/node_modules/react-native-maps/android/bin/build.gradle
new file mode 100644
index 0000000..0070417
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/build.gradle
@@ -0,0 +1,106 @@
+def safeExtGet(prop, fallback) {
+    rootProject.ext.has(prop) ? rootProject.ext.get(prop) : fallback
+}
+
+buildscript {
+    def kotlin_version = rootProject.ext.has('kotlinVersion') ? rootProject.ext.get('kotlinVersion') : '2.0.21'
+    // The Android Gradle plugin is only required when opening the android folder stand-alone.
+    // This avoids unnecessary downloads and potential conflicts when the library is included as a
+    // module dependency in an application project.
+    if (project == rootProject) {
+        repositories {
+            google()
+            mavenCentral()
+        }
+        dependencies {
+            classpath("com.android.tools.build:gradle:8.7.2")
+            classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:${kotlin_version}")
+        }
+    }
+}
+
+def supportsNamespace() {
+    def parsed = com.android.Version.ANDROID_GRADLE_PLUGIN_VERSION.tokenize('.')
+    def major = parsed[0].toInteger()
+    def minor = parsed[1].toInteger()
+
+    // Namespace support was added in 7.3.0
+    if (major == 7 && minor >= 3) {
+        return true
+    }
+
+    return major >= 8
+}
+
+def isNewArchitectureEnabled() {
+    return project.hasProperty("newArchEnabled") && (project.newArchEnabled == "true" || project.newArchEnabled == true)
+}
+
+apply plugin: 'com.android.library'
+if (isNewArchitectureEnabled()) {
+    apply plugin: 'com.facebook.react'
+}
+apply plugin: 'kotlin-android'
+
+android {
+    if (supportsNamespace()) {
+        namespace "com.rnmaps.maps"
+    }
+
+    if (rootProject.hasProperty("ndkPath")) {
+        ndkPath rootProject.ext.ndkPath
+    }
+    if (rootProject.hasProperty("ndkVersion")) {
+        ndkVersion rootProject.ext.ndkVersion
+    }
+
+    compileSdk safeExtGet('compileSdkVersion', 35)
+
+    defaultConfig {
+        minSdkVersion safeExtGet('minSdkVersion', 21)
+        targetSdkVersion safeExtGet('targetSdkVersion', 35)
+
+        buildConfigField "boolean", "IS_NEW_ARCHITECTURE_ENABLED", isNewArchitectureEnabled().toString()
+
+        ndk {
+            abiFilters(*reactNativeArchitectures())
+        }
+    }
+    packagingOptions {
+        excludes = [
+                "META-INF",
+                "META-INF/**",
+                "**/libreact_render*.so",
+        ]
+    }
+
+  buildFeatures {
+          buildConfig = true
+          prefab = true
+  }
+}
+
+def reactNativeArchitectures() {
+    def value = project.getProperties().get("reactNativeArchitectures")
+    return value ? value.split(",") : ["armeabi-v7a", "x86", "x86_64", "arm64-v8a"]
+}
+
+repositories {
+    mavenLocal()
+    mavenCentral()
+    maven {
+        // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm
+        url "$projectDir/../node_modules/react-native/android"
+    }
+    google()
+}
+
+dependencies {
+    implementation 'com.facebook.react:react-native:+'
+    implementation "com.google.android.gms:play-services-base:${safeExtGet('googlePlayServicesBaseVersion', '18.5.0')}"
+    implementation "com.google.android.gms:play-services-maps:${safeExtGet('googlePlayServicesMapsVersion', '19.1.0')}"
+    implementation "com.google.android.gms:play-services-location:${safeExtGet('googlePlayServicesLocationVersion', '21.3.0')}"
+    implementation 'com.google.maps.android:android-maps-utils:3.10.0'
+    implementation "androidx.work:work-runtime:2.9.1"
+}
+
diff --git a/node_modules/react-native-maps/android/bin/gradle/wrapper/gradle-wrapper.jar b/node_modules/react-native-maps/android/bin/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000..7454180
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/node_modules/react-native-maps/android/bin/gradle/wrapper/gradle-wrapper.properties b/node_modules/react-native-maps/android/bin/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..e69d040
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,5 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.3-all.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/node_modules/react-native-maps/android/bin/gradlew b/node_modules/react-native-maps/android/bin/gradlew
new file mode 100755
index 0000000..f3b75f3
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/gradlew
@@ -0,0 +1,251 @@
+#!/bin/sh
+
+#
+# Copyright © 2015-2021 the original authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+
+##############################################################################
+#
+#   Gradle start up script for POSIX generated by Gradle.
+#
+#   Important for running:
+#
+#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
+#       noncompliant, but you have some other compliant shell such as ksh or
+#       bash, then to run this script, type that shell name before the whole
+#       command line, like:
+#
+#           ksh Gradle
+#
+#       Busybox and similar reduced shells will NOT work, because this script
+#       requires all of these POSIX shell features:
+#         * functions;
+#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
+#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
+#         * compound commands having a testable exit status, especially «case»;
+#         * various built-in commands including «command», «set», and «ulimit».
+#
+#   Important for patching:
+#
+#   (2) This script targets any POSIX shell, so it avoids extensions provided
+#       by Bash, Ksh, etc; in particular arrays are avoided.
+#
+#       The "traditional" practice of packing multiple parameters into a
+#       space-separated string is a well documented source of bugs and security
+#       problems, so this is (mostly) avoided, by progressively accumulating
+#       options in "$@", and eventually passing that to Java.
+#
+#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
+#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
+#       see the in-line comments for details.
+#
+#       There are tweaks for specific operating systems such as AIX, CygWin,
+#       Darwin, MinGW, and NonStop.
+#
+#   (3) This script is generated from the Groovy template
+#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
+#       within the Gradle project.
+#
+#       You can find Gradle at https://github.com/gradle/gradle/.
+#
+##############################################################################
+
+# Attempt to set APP_HOME
+
+# Resolve links: $0 may be a link
+app_path=$0
+
+# Need this for daisy-chained symlinks.
+while
+    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
+    [ -h "$app_path" ]
+do
+    ls=$( ls -ld "$app_path" )
+    link=${ls#*' -> '}
+    case $link in             #(
+      /*)   app_path=$link ;; #(
+      *)    app_path=$APP_HOME$link ;;
+    esac
+done
+
+# This is normally unused
+# shellcheck disable=SC2034
+APP_BASE_NAME=${0##*/}
+# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
+APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD=maximum
+
+warn () {
+    echo "$*"
+} >&2
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+} >&2
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "$( uname )" in                #(
+  CYGWIN* )         cygwin=true  ;; #(
+  Darwin* )         darwin=true  ;; #(
+  MSYS* | MINGW* )  msys=true    ;; #(
+  NONSTOP* )        nonstop=true ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD=$JAVA_HOME/jre/sh/java
+    else
+        JAVACMD=$JAVA_HOME/bin/java
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD=java
+    if ! command -v java >/dev/null 2>&1
+    then
+        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+fi
+
+# Increase the maximum file descriptors if we can.
+if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
+    case $MAX_FD in #(
+      max*)
+        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        MAX_FD=$( ulimit -H -n ) ||
+            warn "Could not query maximum file descriptor limit"
+    esac
+    case $MAX_FD in  #(
+      '' | soft) :;; #(
+      *)
+        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        ulimit -n "$MAX_FD" ||
+            warn "Could not set maximum file descriptor limit to $MAX_FD"
+    esac
+fi
+
+# Collect all arguments for the java command, stacking in reverse order:
+#   * args from the command line
+#   * the main class name
+#   * -classpath
+#   * -D...appname settings
+#   * --module-path (only if needed)
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if "$cygwin" || "$msys" ; then
+    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
+    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
+
+    JAVACMD=$( cygpath --unix "$JAVACMD" )
+
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    for arg do
+        if
+            case $arg in                                #(
+              -*)   false ;;                            # don't mess with options #(
+              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
+                    [ -e "$t" ] ;;                      #(
+              *)    false ;;
+            esac
+        then
+            arg=$( cygpath --path --ignore --mixed "$arg" )
+        fi
+        # Roll the args list around exactly as many times as the number of
+        # args, so each arg winds up back in the position where it started, but
+        # possibly modified.
+        #
+        # NB: a `for` loop captures its iteration list before it begins, so
+        # changing the positional parameters here affects neither the number of
+        # iterations, nor the values presented in `arg`.
+        shift                   # remove old arg
+        set -- "$@" "$arg"      # push replacement arg
+    done
+fi
+
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Collect all arguments for the java command:
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
+#     and any embedded shellness will be escaped.
+#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
+#     treated as '${Hostname}' itself on the command line.
+
+set -- \
+        "-Dorg.gradle.appname=$APP_BASE_NAME" \
+        -classpath "$CLASSPATH" \
+        org.gradle.wrapper.GradleWrapperMain \
+        "$@"
+
+# Stop when "xargs" is not available.
+if ! command -v xargs >/dev/null 2>&1
+then
+    die "xargs is not available"
+fi
+
+# Use "xargs" to parse quoted args.
+#
+# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
+#
+# In Bash we could simply go:
+#
+#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
+#   set -- "${ARGS[@]}" "$@"
+#
+# but POSIX shell has neither arrays nor command substitution, so instead we
+# post-process each arg (as a line of input to sed) to backslash-escape any
+# character that might be a shell metacharacter, then use eval to reverse
+# that process (while maintaining the separation between arguments), and wrap
+# the whole thing up as a single "set" statement.
+#
+# This will of course break if any of these variables contains a newline or
+# an unmatched quote.
+#
+
+eval "set -- $(
+        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
+        xargs -n1 |
+        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
+        tr '\n' ' '
+    )" '"$@"'
+
+exec "$JAVACMD" "$@"
diff --git a/node_modules/react-native-maps/android/bin/gradlew.bat b/node_modules/react-native-maps/android/bin/gradlew.bat
new file mode 100644
index 0000000..9d21a21
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/gradlew.bat
@@ -0,0 +1,94 @@
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+@rem SPDX-License-Identifier: Apache-2.0
+@rem
+
+@if "%DEBUG%"=="" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%"=="" set DIRNAME=.
+@rem This is normally unused
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if %ERRORLEVEL% equ 0 goto execute
+
+echo. 1>&2
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto execute
+
+echo. 1>&2
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
+
+goto fail
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
+
+:end
+@rem End local scope for the variables with windows NT shell
+if %ERRORLEVEL% equ 0 goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+set EXIT_CODE=%ERRORLEVEL%
+if %EXIT_CODE% equ 0 set EXIT_CODE=1
+if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
+exit /b %EXIT_CODE%
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/node_modules/react-native-maps/android/bin/src/main/AndroidManifest.xml b/node_modules/react-native-maps/android/bin/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..a2f47b6
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android">
+</manifest>
diff --git a/node_modules/react-native-maps/android/bin/src/main/RCTAppDependencyProvider.h b/node_modules/react-native-maps/android/bin/src/main/RCTAppDependencyProvider.h
new file mode 100644
index 0000000..5a1502d
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/RCTAppDependencyProvider.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+
+#import <Foundation/Foundation.h>
+
+#if __has_include(<React-RCTAppDelegate/RCTDependencyProvider.h>)
+#import <React-RCTAppDelegate/RCTDependencyProvider.h>
+#elif __has_include(<React_RCTAppDelegate/RCTDependencyProvider.h>)
+#import <React_RCTAppDelegate/RCTDependencyProvider.h>
+#else
+#import "RCTDependencyProvider.h"
+#endif
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RCTAppDependencyProvider : NSObject <RCTDependencyProvider>
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/node_modules/react-native-maps/android/bin/src/main/RCTAppDependencyProvider.mm b/node_modules/react-native-maps/android/bin/src/main/RCTAppDependencyProvider.mm
new file mode 100644
index 0000000..6159447
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/RCTAppDependencyProvider.mm
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#import "RCTAppDependencyProvider.h"
+#import <ReactCodegen/RCTModulesConformingToProtocolsProvider.h>
+#import <ReactCodegen/RCTThirdPartyComponentsProvider.h>
+
+@implementation RCTAppDependencyProvider {
+  NSArray<NSString *> * _URLRequestHandlerClassNames;
+  NSArray<NSString *> * _imageDataDecoderClassNames;
+  NSArray<NSString *> * _imageURLLoaderClassNames;
+  NSDictionary<NSString *,Class<RCTComponentViewProtocol>> * _thirdPartyFabricComponents;
+}
+
+- (nonnull NSArray<NSString *> *)URLRequestHandlerClassNames {
+  static dispatch_once_t requestUrlToken;
+  dispatch_once(&requestUrlToken, ^{
+    self->_URLRequestHandlerClassNames = RCTModulesConformingToProtocolsProvider.URLRequestHandlerClassNames;
+  });
+
+  return _URLRequestHandlerClassNames;
+}
+
+- (nonnull NSArray<NSString *> *)imageDataDecoderClassNames {
+  static dispatch_once_t dataDecoderToken;
+  dispatch_once(&dataDecoderToken, ^{
+    _imageDataDecoderClassNames = RCTModulesConformingToProtocolsProvider.imageDataDecoderClassNames;
+  });
+
+  return _imageDataDecoderClassNames;
+}
+
+- (nonnull NSArray<NSString *> *)imageURLLoaderClassNames {
+  static dispatch_once_t urlLoaderToken;
+  dispatch_once(&urlLoaderToken, ^{
+    _imageURLLoaderClassNames = RCTModulesConformingToProtocolsProvider.imageURLLoaderClassNames;
+  });
+
+  return _imageURLLoaderClassNames;
+}
+
+- (nonnull NSDictionary<NSString *,Class<RCTComponentViewProtocol>> *)thirdPartyFabricComponents {
+  static dispatch_once_t nativeComponentsToken;
+  dispatch_once(&nativeComponentsToken, ^{
+    _thirdPartyFabricComponents = RCTThirdPartyComponentsProvider.thirdPartyFabricComponents;
+  });
+
+  return _thirdPartyFabricComponents;
+}
+
+@end
diff --git a/node_modules/react-native-maps/android/bin/src/main/RCTModulesConformingToProtocolsProvider.h b/node_modules/react-native-maps/android/bin/src/main/RCTModulesConformingToProtocolsProvider.h
new file mode 100644
index 0000000..10eb848
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/RCTModulesConformingToProtocolsProvider.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#import <Foundation/Foundation.h>
+
+@interface RCTModulesConformingToProtocolsProvider: NSObject
+
++(NSArray<NSString *> *)imageURLLoaderClassNames;
+
++(NSArray<NSString *> *)imageDataDecoderClassNames;
+
++(NSArray<NSString *> *)URLRequestHandlerClassNames;
+
+@end
diff --git a/node_modules/react-native-maps/android/bin/src/main/RCTModulesConformingToProtocolsProvider.mm b/node_modules/react-native-maps/android/bin/src/main/RCTModulesConformingToProtocolsProvider.mm
new file mode 100644
index 0000000..c640d4f
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/RCTModulesConformingToProtocolsProvider.mm
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#import "RCTModulesConformingToProtocolsProvider.h"
+
+@implementation RCTModulesConformingToProtocolsProvider
+
++(NSArray<NSString *> *)imageURLLoaderClassNames
+{
+  return @[
+    
+  ];
+}
+
++(NSArray<NSString *> *)imageDataDecoderClassNames
+{
+  return @[
+    
+  ];
+}
+
++(NSArray<NSString *> *)URLRequestHandlerClassNames
+{
+  return @[
+    
+  ];
+}
+
+@end
diff --git a/node_modules/react-native-maps/android/bin/src/main/RCTThirdPartyComponentsProvider.h b/node_modules/react-native-maps/android/bin/src/main/RCTThirdPartyComponentsProvider.h
new file mode 100644
index 0000000..ab1a249
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/RCTThirdPartyComponentsProvider.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#import <Foundation/Foundation.h>
+
+@protocol RCTComponentViewProtocol;
+
+@interface RCTThirdPartyComponentsProvider: NSObject
+
++ (NSDictionary<NSString *, Class<RCTComponentViewProtocol>> *)thirdPartyFabricComponents;
+
+@end
diff --git a/node_modules/react-native-maps/android/bin/src/main/RCTThirdPartyComponentsProvider.mm b/node_modules/react-native-maps/android/bin/src/main/RCTThirdPartyComponentsProvider.mm
new file mode 100644
index 0000000..94c2d24
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/RCTThirdPartyComponentsProvider.mm
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+
+#import <Foundation/Foundation.h>
+
+#import "RCTThirdPartyComponentsProvider.h"
+#import <React/RCTComponentViewProtocol.h>
+
+@implementation RCTThirdPartyComponentsProvider
+
++ (NSDictionary<NSString *, Class<RCTComponentViewProtocol>> *)thirdPartyFabricComponents
+{
+  return @{
+		@"RNMapsGoogleMapView": NSClassFromString(@"RNMapsGoogleMapView"), // react-native-maps
+		@"RNMapsGooglePolygon": NSClassFromString(@"RNMapsGooglePolygonView"), // react-native-maps
+		@"RNMapsMapView": NSClassFromString(@"RNMapsMapView"), // react-native-maps
+		@"RNMapsMarker": NSClassFromString(@"RNMapsMarkerView"), // react-native-maps
+  };
+}
+
+@end
diff --git a/node_modules/react-native-maps/android/bin/src/main/ReactAppDependencyProvider.podspec b/node_modules/react-native-maps/android/bin/src/main/ReactAppDependencyProvider.podspec
new file mode 100644
index 0000000..61c8336
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/ReactAppDependencyProvider.podspec
@@ -0,0 +1,34 @@
+# Copyright (c) Meta Platforms, Inc. and affiliates.
+#
+# This source code is licensed under the MIT license found in the
+# LICENSE file in the root directory of this source tree.
+
+version = "0.77.2"
+source = { :git => 'https://github.com/facebook/react-native.git' }
+if version == '1000.0.0'
+  # This is an unpublished version, use the latest commit hash of the react-native repo, which we’re presumably in.
+  source[:commit] = `git rev-parse HEAD`.strip if system("git rev-parse --git-dir > /dev/null 2>&1")
+else
+  source[:tag] = "v#{version}"
+end
+
+Pod::Spec.new do |s|
+  s.name                   = "ReactAppDependencyProvider"
+  s.version                = version
+  s.summary                = "The third party dependency provider for the app"
+  s.homepage               = "https://reactnative.dev/"
+  s.documentation_url      = "https://reactnative.dev/"
+  s.license                = "MIT"
+  s.author                 = "Meta Platforms, Inc. and its affiliates"
+  s.platforms              = min_supported_versions
+  s.source                 = source
+  s.source_files           = "**/RCTAppDependencyProvider.{h,mm}"
+
+  # This guard prevent to install the dependencies when we run `pod install` in the old architecture.
+  s.pod_target_xcconfig    = {
+    "CLANG_CXX_LANGUAGE_STANDARD" => rct_cxx_language_standard(),
+    "DEFINES_MODULE" => "YES"
+  }
+
+  s.dependency "ReactCodegen"
+end
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/fbreact/specs/NativeAirMapsModuleSpec.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/fbreact/specs/NativeAirMapsModuleSpec.class
new file mode 100644
index 0000000..ad153e8
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/fbreact/specs/NativeAirMapsModuleSpec.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCalloutManagerDelegate.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCalloutManagerDelegate.class
new file mode 100644
index 0000000..faec2e7
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCalloutManagerDelegate.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCalloutManagerInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCalloutManagerInterface.class
new file mode 100644
index 0000000..e8cb0ed
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCalloutManagerInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCircleManagerDelegate.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCircleManagerDelegate.class
new file mode 100644
index 0000000..69e05ab
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCircleManagerDelegate.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCircleManagerInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCircleManagerInterface.class
new file mode 100644
index 0000000..b92d78d
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsCircleManagerInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsGooglePolygonManagerDelegate.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsGooglePolygonManagerDelegate.class
new file mode 100644
index 0000000..b6f09c3
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsGooglePolygonManagerDelegate.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsGooglePolygonManagerInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsGooglePolygonManagerInterface.class
new file mode 100644
index 0000000..38e0e57
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsGooglePolygonManagerInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMapViewManagerDelegate.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMapViewManagerDelegate.class
new file mode 100644
index 0000000..386e299
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMapViewManagerDelegate.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMapViewManagerInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMapViewManagerInterface.class
new file mode 100644
index 0000000..03799f4
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMapViewManagerInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMarkerManagerDelegate.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMarkerManagerDelegate.class
new file mode 100644
index 0000000..292e434
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMarkerManagerDelegate.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMarkerManagerInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMarkerManagerInterface.class
new file mode 100644
index 0000000..4b71726
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsMarkerManagerInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsOverlayManagerDelegate.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsOverlayManagerDelegate.class
new file mode 100644
index 0000000..959e106
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsOverlayManagerDelegate.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsOverlayManagerInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsOverlayManagerInterface.class
new file mode 100644
index 0000000..953ba03
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsOverlayManagerInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsPolylineManagerDelegate.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsPolylineManagerDelegate.class
new file mode 100644
index 0000000..47637f5
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsPolylineManagerDelegate.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsPolylineManagerInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsPolylineManagerInterface.class
new file mode 100644
index 0000000..add2ad0
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsPolylineManagerInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsUrlTileManagerDelegate.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsUrlTileManagerDelegate.class
new file mode 100644
index 0000000..767eb71
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsUrlTileManagerDelegate.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsUrlTileManagerInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsUrlTileManagerInterface.class
new file mode 100644
index 0000000..1b8f20f
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsUrlTileManagerInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsWMSTileManagerDelegate.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsWMSTileManagerDelegate.class
new file mode 100644
index 0000000..9254fff
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsWMSTileManagerDelegate.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsWMSTileManagerInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsWMSTileManagerInterface.class
new file mode 100644
index 0000000..e6e95a1
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/facebook/react/viewmanagers/RNMapsWMSTileManagerInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/CalloutManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/CalloutManager.class
new file mode 100644
index 0000000..2fe4444
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/CalloutManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/CircleManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/CircleManager.class
new file mode 100644
index 0000000..1eef810
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/CircleManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/JSONUtil.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/JSONUtil.class
new file mode 100644
index 0000000..9990f27
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/JSONUtil.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/MapViewManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/MapViewManager.class
new file mode 100644
index 0000000..99f58a9
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/MapViewManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/MarkerManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/MarkerManager.class
new file mode 100644
index 0000000..37e5ff7
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/MarkerManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/NativeAirMapsModule.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/NativeAirMapsModule.class
new file mode 100644
index 0000000..4d1c957
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/NativeAirMapsModule.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/OverlayManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/OverlayManager.class
new file mode 100644
index 0000000..5b8d2a6
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/OverlayManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/PolygonManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/PolygonManager.class
new file mode 100644
index 0000000..2dfb9c6
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/PolygonManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/PolylineManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/PolylineManager.class
new file mode 100644
index 0000000..aa0a27a
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/PolylineManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/UrlTileManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/UrlTileManager.class
new file mode 100644
index 0000000..a6304fa
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/UrlTileManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/WMSTileManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/WMSTileManager.class
new file mode 100644
index 0000000..0a90039
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/WMSTileManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnCalloutPressEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnCalloutPressEvent.class
new file mode 100644
index 0000000..1504ffc
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnCalloutPressEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDeselectEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDeselectEvent.class
new file mode 100644
index 0000000..5597503
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDeselectEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDoublePressEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDoublePressEvent.class
new file mode 100644
index 0000000..746d07f
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDoublePressEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDragEndEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDragEndEvent.class
new file mode 100644
index 0000000..285fa9a
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDragEndEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDragEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDragEvent.class
new file mode 100644
index 0000000..79b02df
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDragEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDragStartEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDragStartEvent.class
new file mode 100644
index 0000000..a11bed0
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnDragStartEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnIndoorBuildingFocusedEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnIndoorBuildingFocusedEvent.class
new file mode 100644
index 0000000..e11de67
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnIndoorBuildingFocusedEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnIndoorLevelActivatedEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnIndoorLevelActivatedEvent.class
new file mode 100644
index 0000000..eb1b0c8
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnIndoorLevelActivatedEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnKmlReadyEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnKmlReadyEvent.class
new file mode 100644
index 0000000..7178aaa
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnKmlReadyEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnLongPressEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnLongPressEvent.class
new file mode 100644
index 0000000..b98239a
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnLongPressEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMapLoadedEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMapLoadedEvent.class
new file mode 100644
index 0000000..15d1b40
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMapLoadedEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMapReadyEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMapReadyEvent.class
new file mode 100644
index 0000000..a3780ef
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMapReadyEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDeselectEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDeselectEvent.class
new file mode 100644
index 0000000..3f633c7
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDeselectEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDragEndEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDragEndEvent.class
new file mode 100644
index 0000000..7de3696
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDragEndEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDragEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDragEvent.class
new file mode 100644
index 0000000..0e4c426
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDragEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDragStartEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDragStartEvent.class
new file mode 100644
index 0000000..37d4c80
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerDragStartEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerPressEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerPressEvent.class
new file mode 100644
index 0000000..4636750
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerPressEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerSelectEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerSelectEvent.class
new file mode 100644
index 0000000..0333fe0
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnMarkerSelectEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnPanDragEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnPanDragEvent.class
new file mode 100644
index 0000000..dc70ad9
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnPanDragEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnPoiClickEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnPoiClickEvent.class
new file mode 100644
index 0000000..a56a15f
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnPoiClickEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnPressEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnPressEvent.class
new file mode 100644
index 0000000..e2ad337
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnPressEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnRegionChangeCompleteEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnRegionChangeCompleteEvent.class
new file mode 100644
index 0000000..99fd92b
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnRegionChangeCompleteEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnRegionChangeEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnRegionChangeEvent.class
new file mode 100644
index 0000000..894824d
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnRegionChangeEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnRegionChangeStartEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnRegionChangeStartEvent.class
new file mode 100644
index 0000000..c3d9610
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnRegionChangeStartEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnSelectEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnSelectEvent.class
new file mode 100644
index 0000000..8d235d5
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnSelectEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnUserLocationChangeEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnUserLocationChangeEvent.class
new file mode 100644
index 0000000..5866a16
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/fabric/event/OnUserLocationChangeEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/FileUtil.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/FileUtil.class
new file mode 100644
index 0000000..7832003
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/FileUtil.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/FusedLocationSource.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/FusedLocationSource.class
new file mode 100644
index 0000000..9fbd070
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/FusedLocationSource.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ImageReadable.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ImageReadable.class
new file mode 100644
index 0000000..a8d23d6
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ImageReadable.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ImageReader.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ImageReader.class
new file mode 100644
index 0000000..c607612
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ImageReader.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ImageUtil.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ImageUtil.class
new file mode 100644
index 0000000..112146e
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ImageUtil.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/LatLngBoundsUtils.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/LatLngBoundsUtils.class
new file mode 100644
index 0000000..05b5f50
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/LatLngBoundsUtils.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCallout.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCallout.class
new file mode 100644
index 0000000..d7af532
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCallout.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCalloutManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCalloutManager.class
new file mode 100644
index 0000000..819e365
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCalloutManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCircle.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCircle.class
new file mode 100644
index 0000000..cb29411
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCircle.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCircleManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCircleManager.class
new file mode 100644
index 0000000..97c7cfd
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapCircleManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapFeature.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapFeature.class
new file mode 100644
index 0000000..b3f169d
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapFeature.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolyline$AirMapGradientPolylineProvider.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolyline$AirMapGradientPolylineProvider.class
new file mode 100644
index 0000000..38d37ef
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolyline$AirMapGradientPolylineProvider.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolyline$MutPoint.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolyline$MutPoint.class
new file mode 100644
index 0000000..c7a73df
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolyline$MutPoint.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolyline.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolyline.class
new file mode 100644
index 0000000..66d9fb9
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolyline.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolylineManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolylineManager.class
new file mode 100644
index 0000000..015e6c8
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapGradientPolylineManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapHeatmap.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapHeatmap.class
new file mode 100644
index 0000000..7f33678
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapHeatmap.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapHeatmapManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapHeatmapManager.class
new file mode 100644
index 0000000..825282f
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapHeatmapManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapLocalTile$AIRMapLocalTileProvider.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapLocalTile$AIRMapLocalTileProvider.class
new file mode 100644
index 0000000..d0c69e6
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapLocalTile$AIRMapLocalTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapLocalTile.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapLocalTile.class
new file mode 100644
index 0000000..252c14e
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapLocalTile.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapLocalTileManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapLocalTileManager.class
new file mode 100644
index 0000000..b3287ca
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapLocalTileManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapManager.class
new file mode 100644
index 0000000..3c09a25
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarker$EventCreator.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarker$EventCreator.class
new file mode 100644
index 0000000..310cf55
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarker$EventCreator.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarker.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarker.class
new file mode 100644
index 0000000..e3ab385
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarker.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarkerManager$AirMapMarkerSharedIcon.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarkerManager$AirMapMarkerSharedIcon.class
new file mode 100644
index 0000000..c8fc8b4
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarkerManager$AirMapMarkerSharedIcon.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarkerManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarkerManager.class
new file mode 100644
index 0000000..0108af9
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapMarkerManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapModule.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapModule.class
new file mode 100644
index 0000000..2293230
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapModule.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapOverlay.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapOverlay.class
new file mode 100644
index 0000000..d291760
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapOverlay.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapOverlayManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapOverlayManager.class
new file mode 100644
index 0000000..bff6f17
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapOverlayManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolygon.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolygon.class
new file mode 100644
index 0000000..c3c53bb
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolygon.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolygonManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolygonManager.class
new file mode 100644
index 0000000..8feb253
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolygonManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolyline.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolyline.class
new file mode 100644
index 0000000..8e7101f
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolyline.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolylineManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolylineManager.class
new file mode 100644
index 0000000..e1a1f60
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapPolylineManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapTileProvider$AIRMapUrlTileProvider.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapTileProvider$AIRMapUrlTileProvider.class
new file mode 100644
index 0000000..ce4732d
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapTileProvider$AIRMapUrlTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapTileProvider.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapTileProvider.class
new file mode 100644
index 0000000..3ed8fa4
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapTileWorker.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapTileWorker.class
new file mode 100644
index 0000000..57488d6
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapTileWorker.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapUIBlock.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapUIBlock.class
new file mode 100644
index 0000000..f349a9a
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapUIBlock.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapUrlTile.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapUrlTile.class
new file mode 100644
index 0000000..f3e9bd9
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapUrlTile.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapUrlTileManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapUrlTileManager.class
new file mode 100644
index 0000000..9217907
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapUrlTileManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapView$EventCreator.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapView$EventCreator.class
new file mode 100644
index 0000000..09c46b4
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapView$EventCreator.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapView.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapView.class
new file mode 100644
index 0000000..8e96d5d
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapView.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider$AIRMapWMSTileProvider.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider$AIRMapWMSTileProvider.class
new file mode 100644
index 0000000..00fdc0b
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider$AIRMapWMSTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider.class
new file mode 100644
index 0000000..2c067bc
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTile$AIRMapGSUrlTileProvider.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTile.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTile.class
new file mode 100644
index 0000000..484713b
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTile.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTileManager.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTileManager.class
new file mode 100644
index 0000000..b870ac2
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapWMSTileManager.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapsPackage.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapsPackage.class
new file mode 100644
index 0000000..3d3fbc3
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/MapsPackage.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/RegionChangeEvent.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/RegionChangeEvent.class
new file mode 100644
index 0000000..9aa479f
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/RegionChangeEvent.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/SizeReportingShadowNode.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/SizeReportingShadowNode.class
new file mode 100644
index 0000000..50f165f
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/SizeReportingShadowNode.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/UIBlockInterface.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/UIBlockInterface.class
new file mode 100644
index 0000000..838566d
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/UIBlockInterface.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ViewAttacherGroup.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ViewAttacherGroup.class
new file mode 100644
index 0000000..60a2d86
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ViewAttacherGroup.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ViewChangesTracker.class b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ViewChangesTracker.class
new file mode 100644
index 0000000..d25a87c
Binary files /dev/null and b/node_modules/react-native-maps/android/bin/src/main/java/com/rnmaps/maps/ViewChangesTracker.class differ
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/CMakeLists.txt b/node_modules/react-native-maps/android/bin/src/main/jni/CMakeLists.txt
new file mode 100644
index 0000000..ddb85f5
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/CMakeLists.txt
@@ -0,0 +1,28 @@
+# Copyright (c) Meta Platforms, Inc. and affiliates.
+#
+# This source code is licensed under the MIT license found in the
+# LICENSE file in the root directory of this source tree.
+
+cmake_minimum_required(VERSION 3.13)
+set(CMAKE_VERBOSE_MAKEFILE on)
+
+file(GLOB react_codegen_SRCS CONFIGURE_DEPENDS *.cpp react/renderer/components/RNMapsSpecs/*.cpp)
+
+add_library(
+  react_codegen_RNMapsSpecs
+  OBJECT
+  ${react_codegen_SRCS}
+)
+
+target_include_directories(react_codegen_RNMapsSpecs PUBLIC . react/renderer/components/RNMapsSpecs)
+
+target_link_libraries(
+  react_codegen_RNMapsSpecs
+  fbjni
+  jsi
+  # We need to link different libraries based on whether we are building rncore or not, that's necessary
+  # because we want to break a circular dependency between react_codegen_rncore and reactnative
+  reactnative
+)
+
+target_compile_reactnative_options(react_codegen_RNMapsSpecs PRIVATE)
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/RNMapsSpecs-generated.cpp b/node_modules/react-native-maps/android/bin/src/main/jni/RNMapsSpecs-generated.cpp
new file mode 100644
index 0000000..554d370
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/RNMapsSpecs-generated.cpp
@@ -0,0 +1,68 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniCpp.js
+ */
+
+#include "RNMapsSpecs.h"
+
+namespace facebook::react {
+
+static facebook::jsi::Value __hostFunction_NativeAirMapsModuleSpecJSI_getCamera(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getCamera", "(DLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAirMapsModuleSpecJSI_getMarkersFrames(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getMarkersFrames", "(DZLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAirMapsModuleSpecJSI_getMapBoundaries(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getMapBoundaries", "(DLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAirMapsModuleSpecJSI_takeSnapshot(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "takeSnapshot", "(DLjava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAirMapsModuleSpecJSI_getAddressFromCoordinates(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getAddressFromCoordinates", "(DLcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAirMapsModuleSpecJSI_getPointForCoordinate(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getPointForCoordinate", "(DLcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAirMapsModuleSpecJSI_getCoordinateForPoint(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getCoordinateForPoint", "(DLcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeAirMapsModuleSpecJSI::NativeAirMapsModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getCamera"] = MethodMetadata {1, __hostFunction_NativeAirMapsModuleSpecJSI_getCamera};
+  methodMap_["getMarkersFrames"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleSpecJSI_getMarkersFrames};
+  methodMap_["getMapBoundaries"] = MethodMetadata {1, __hostFunction_NativeAirMapsModuleSpecJSI_getMapBoundaries};
+  methodMap_["takeSnapshot"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleSpecJSI_takeSnapshot};
+  methodMap_["getAddressFromCoordinates"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleSpecJSI_getAddressFromCoordinates};
+  methodMap_["getPointForCoordinate"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleSpecJSI_getPointForCoordinate};
+  methodMap_["getCoordinateForPoint"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleSpecJSI_getCoordinateForPoint};
+}
+
+std::shared_ptr<TurboModule> RNMapsSpecs_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params) {
+  if (moduleName == "RNMapsAirModule") {
+    return std::make_shared<NativeAirMapsModuleSpecJSI>(params);
+  }
+  return nullptr;
+}
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/RNMapsSpecs.h b/node_modules/react-native-maps/android/bin/src/main/jni/RNMapsSpecs.h
new file mode 100644
index 0000000..91bf54f
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/RNMapsSpecs.h
@@ -0,0 +1,31 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/JavaTurboModule.h>
+#include <ReactCommon/TurboModule.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+/**
+ * JNI C++ class for module 'NativeAirMapsModule'
+ */
+class JSI_EXPORT NativeAirMapsModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeAirMapsModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+
+JSI_EXPORT
+std::shared_ptr<TurboModule> RNMapsSpecs_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params);
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ComponentDescriptors.cpp b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ComponentDescriptors.cpp
new file mode 100644
index 0000000..affc513
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ComponentDescriptors.cpp
@@ -0,0 +1,31 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorCpp.js
+ */
+
+#include "ComponentDescriptors.h"
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+void RNMapsSpecs_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry) {
+registry->add(concreteComponentDescriptorProvider<RNMapsCalloutComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMapsCircleComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMapsGoogleMapViewComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMapsGooglePolygonComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMapsMapViewComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMapsMarkerComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMapsOverlayComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMapsPolylineComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMapsUrlTileComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<RNMapsWMSTileComponentDescriptor>());
+}
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ComponentDescriptors.h b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ComponentDescriptors.h
new file mode 100644
index 0000000..68a015d
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ComponentDescriptors.h
@@ -0,0 +1,33 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorH.js
+ */
+
+#pragma once
+
+#include "ShadowNodes.h"
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+using RNMapsCalloutComponentDescriptor = ConcreteComponentDescriptor<RNMapsCalloutShadowNode>;
+using RNMapsCircleComponentDescriptor = ConcreteComponentDescriptor<RNMapsCircleShadowNode>;
+using RNMapsGoogleMapViewComponentDescriptor = ConcreteComponentDescriptor<RNMapsGoogleMapViewShadowNode>;
+using RNMapsGooglePolygonComponentDescriptor = ConcreteComponentDescriptor<RNMapsGooglePolygonShadowNode>;
+using RNMapsMapViewComponentDescriptor = ConcreteComponentDescriptor<RNMapsMapViewShadowNode>;
+using RNMapsMarkerComponentDescriptor = ConcreteComponentDescriptor<RNMapsMarkerShadowNode>;
+using RNMapsOverlayComponentDescriptor = ConcreteComponentDescriptor<RNMapsOverlayShadowNode>;
+using RNMapsPolylineComponentDescriptor = ConcreteComponentDescriptor<RNMapsPolylineShadowNode>;
+using RNMapsUrlTileComponentDescriptor = ConcreteComponentDescriptor<RNMapsUrlTileShadowNode>;
+using RNMapsWMSTileComponentDescriptor = ConcreteComponentDescriptor<RNMapsWMSTileShadowNode>;
+
+void RNMapsSpecs_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry);
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/EventEmitters.cpp b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/EventEmitters.cpp
new file mode 100644
index 0000000..290044a
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/EventEmitters.cpp
@@ -0,0 +1,979 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterCpp.js
+ */
+
+#include "EventEmitters.h"
+
+
+namespace facebook::react {
+
+void RNMapsCalloutEventEmitter::onPress(OnPress event) const {
+  dispatchEvent("press", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsCircleEventEmitter::onPress(OnPress event) const {
+  dispatchEvent("press", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onIndoorBuildingFocused(OnIndoorBuildingFocused event) const {
+  dispatchEvent("indoorBuildingFocused", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "underground", event.underground);
+payload.setProperty(runtime, "activeLevelIndex", event.activeLevelIndex);
+payload.setProperty(runtime, "levels", event.levels);
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onIndoorLevelActivated(OnIndoorLevelActivated event) const {
+  dispatchEvent("indoorLevelActivated", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "activeLevelIndex", event.activeLevelIndex);
+payload.setProperty(runtime, "name", event.name);
+payload.setProperty(runtime, "shortName", event.shortName);
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onKmlReady(OnKmlReady event) const {
+  dispatchEvent("kmlReady", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onLongPress(OnLongPress event) const {
+  dispatchEvent("longPress", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+payload.setProperty(runtime, "action", event.action);
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onMapLoaded(OnMapLoaded event) const {
+  dispatchEvent("mapLoaded", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onMapReady(OnMapReady event) const {
+  dispatchEvent("mapReady", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onMarkerDeselect(OnMarkerDeselect event) const {
+  dispatchEvent("markerDeselect", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onMarkerDrag(OnMarkerDrag event) const {
+  dispatchEvent("markerDrag", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+payload.setProperty(runtime, "id", event.id);
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onMarkerDragEnd(OnMarkerDragEnd event) const {
+  dispatchEvent("markerDragEnd", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+payload.setProperty(runtime, "id", event.id);
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onMarkerDragStart(OnMarkerDragStart event) const {
+  dispatchEvent("markerDragStart", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+payload.setProperty(runtime, "id", event.id);
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onMarkerPress(OnMarkerPress event) const {
+  dispatchEvent("markerPress", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onMarkerSelect(OnMarkerSelect event) const {
+  dispatchEvent("markerSelect", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onPanDrag(OnPanDrag event) const {
+  dispatchEvent("panDrag", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onPoiClick(OnPoiClick event) const {
+  dispatchEvent("poiClick", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "placeId", event.placeId);
+payload.setProperty(runtime, "name", event.name);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onPress(OnPress event) const {
+  dispatchEvent("press", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+payload.setProperty(runtime, "action", event.action);
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onRegionChangeStart(OnRegionChangeStart event) const {
+  dispatchEvent("regionChangeStart", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto region = jsi::Object(runtime);
+  region.setProperty(runtime, "latitude", event.region.latitude);
+  region.setProperty(runtime, "longitude", event.region.longitude);
+  region.setProperty(runtime, "latitudeDelta", event.region.latitudeDelta);
+  region.setProperty(runtime, "longitudeDelta", event.region.longitudeDelta);
+  payload.setProperty(runtime, "region", region);
+}
+payload.setProperty(runtime, "isGesture", event.isGesture);
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onRegionChange(OnRegionChange event) const {
+  dispatchEvent("regionChange", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto region = jsi::Object(runtime);
+  region.setProperty(runtime, "latitude", event.region.latitude);
+  region.setProperty(runtime, "longitude", event.region.longitude);
+  region.setProperty(runtime, "latitudeDelta", event.region.latitudeDelta);
+  region.setProperty(runtime, "longitudeDelta", event.region.longitudeDelta);
+  payload.setProperty(runtime, "region", region);
+}
+payload.setProperty(runtime, "isGesture", event.isGesture);
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onRegionChangeComplete(OnRegionChangeComplete event) const {
+  dispatchEvent("regionChangeComplete", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto region = jsi::Object(runtime);
+  region.setProperty(runtime, "latitude", event.region.latitude);
+  region.setProperty(runtime, "longitude", event.region.longitude);
+  region.setProperty(runtime, "latitudeDelta", event.region.latitudeDelta);
+  region.setProperty(runtime, "longitudeDelta", event.region.longitudeDelta);
+  payload.setProperty(runtime, "region", region);
+}
+payload.setProperty(runtime, "isGesture", event.isGesture);
+    return payload;
+  });
+}
+
+
+void RNMapsGoogleMapViewEventEmitter::onUserLocationChange(OnUserLocationChange event) const {
+  dispatchEvent("userLocationChange", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  coordinate.setProperty(runtime, "altitude", event.coordinate.altitude);
+  coordinate.setProperty(runtime, "timestamp", event.coordinate.timestamp);
+  coordinate.setProperty(runtime, "accuracy", event.coordinate.accuracy);
+  coordinate.setProperty(runtime, "speed", event.coordinate.speed);
+  coordinate.setProperty(runtime, "heading", event.coordinate.heading);
+  coordinate.setProperty(runtime, "altitudeAccuracy", event.coordinate.altitudeAccuracy);
+  coordinate.setProperty(runtime, "isFromMockProvider", event.coordinate.isFromMockProvider);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto error = jsi::Object(runtime);
+  error.setProperty(runtime, "message", event.error.message);
+  payload.setProperty(runtime, "error", error);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsGooglePolygonEventEmitter::onPress(OnPress event) const {
+  dispatchEvent("press", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onCalloutPress(OnCalloutPress event) const {
+  dispatchEvent("calloutPress", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+{
+  auto frame = jsi::Object(runtime);
+  frame.setProperty(runtime, "x", event.frame.x);
+  frame.setProperty(runtime, "y", event.frame.y);
+  frame.setProperty(runtime, "width", event.frame.width);
+  frame.setProperty(runtime, "height", event.frame.height);
+  payload.setProperty(runtime, "frame", frame);
+}
+payload.setProperty(runtime, "id", event.id);
+{
+  auto point = jsi::Object(runtime);
+  point.setProperty(runtime, "x", event.point.x);
+  point.setProperty(runtime, "y", event.point.y);
+  payload.setProperty(runtime, "point", point);
+}
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onDoublePress(OnDoublePress event) const {
+  dispatchEvent("doublePress", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onIndoorBuildingFocused(OnIndoorBuildingFocused event) const {
+  dispatchEvent("indoorBuildingFocused", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto IndoorBuilding = jsi::Object(runtime);
+  IndoorBuilding.setProperty(runtime, "underground", event.IndoorBuilding.underground);
+  IndoorBuilding.setProperty(runtime, "activeLevelIndex", event.IndoorBuilding.activeLevelIndex);
+  payload.setProperty(runtime, "IndoorBuilding", IndoorBuilding);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onIndoorLevelActivated(OnIndoorLevelActivated event) const {
+  dispatchEvent("indoorLevelActivated", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto IndoorLevel = jsi::Object(runtime);
+  IndoorLevel.setProperty(runtime, "activeLevelIndex", event.IndoorLevel.activeLevelIndex);
+  IndoorLevel.setProperty(runtime, "name", event.IndoorLevel.name);
+  IndoorLevel.setProperty(runtime, "shortName", event.IndoorLevel.shortName);
+  payload.setProperty(runtime, "IndoorLevel", IndoorLevel);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onKmlReady(OnKmlReady event) const {
+  dispatchEvent("kmlReady", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onLongPress(OnLongPress event) const {
+  dispatchEvent("longPress", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+payload.setProperty(runtime, "action", event.action);
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onMapLoaded(OnMapLoaded event) const {
+  dispatchEvent("mapLoaded", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onMapReady(OnMapReady event) const {
+  dispatchEvent("mapReady", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onMarkerDeselect(OnMarkerDeselect event) const {
+  dispatchEvent("markerDeselect", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onMarkerDrag(OnMarkerDrag event) const {
+  dispatchEvent("markerDrag", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+payload.setProperty(runtime, "id", event.id);
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onMarkerDragEnd(OnMarkerDragEnd event) const {
+  dispatchEvent("markerDragEnd", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+payload.setProperty(runtime, "id", event.id);
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onMarkerDragStart(OnMarkerDragStart event) const {
+  dispatchEvent("markerDragStart", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+payload.setProperty(runtime, "id", event.id);
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onMarkerPress(OnMarkerPress event) const {
+  dispatchEvent("markerPress", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onMarkerSelect(OnMarkerSelect event) const {
+  dispatchEvent("markerSelect", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onPanDrag(OnPanDrag event) const {
+  dispatchEvent("panDrag", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onPoiClick(OnPoiClick event) const {
+  dispatchEvent("poiClick", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "placeId", event.placeId);
+payload.setProperty(runtime, "name", event.name);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onPress(OnPress event) const {
+  dispatchEvent("press", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+payload.setProperty(runtime, "action", event.action);
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onRegionChangeStart(OnRegionChangeStart event) const {
+  dispatchEvent("regionChangeStart", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto region = jsi::Object(runtime);
+  region.setProperty(runtime, "latitude", event.region.latitude);
+  region.setProperty(runtime, "longitude", event.region.longitude);
+  region.setProperty(runtime, "latitudeDelta", event.region.latitudeDelta);
+  region.setProperty(runtime, "longitudeDelta", event.region.longitudeDelta);
+  payload.setProperty(runtime, "region", region);
+}
+payload.setProperty(runtime, "isGesture", event.isGesture);
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onRegionChange(OnRegionChange event) const {
+  dispatchEvent("regionChange", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto region = jsi::Object(runtime);
+  region.setProperty(runtime, "latitude", event.region.latitude);
+  region.setProperty(runtime, "longitude", event.region.longitude);
+  region.setProperty(runtime, "latitudeDelta", event.region.latitudeDelta);
+  region.setProperty(runtime, "longitudeDelta", event.region.longitudeDelta);
+  payload.setProperty(runtime, "region", region);
+}
+payload.setProperty(runtime, "isGesture", event.isGesture);
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onRegionChangeComplete(OnRegionChangeComplete event) const {
+  dispatchEvent("regionChangeComplete", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto region = jsi::Object(runtime);
+  region.setProperty(runtime, "latitude", event.region.latitude);
+  region.setProperty(runtime, "longitude", event.region.longitude);
+  region.setProperty(runtime, "latitudeDelta", event.region.latitudeDelta);
+  region.setProperty(runtime, "longitudeDelta", event.region.longitudeDelta);
+  payload.setProperty(runtime, "region", region);
+}
+payload.setProperty(runtime, "isGesture", event.isGesture);
+    return payload;
+  });
+}
+
+
+void RNMapsMapViewEventEmitter::onUserLocationChange(OnUserLocationChange event) const {
+  dispatchEvent("userLocationChange", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    {
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  coordinate.setProperty(runtime, "altitude", event.coordinate.altitude);
+  coordinate.setProperty(runtime, "timestamp", event.coordinate.timestamp);
+  coordinate.setProperty(runtime, "accuracy", event.coordinate.accuracy);
+  coordinate.setProperty(runtime, "speed", event.coordinate.speed);
+  coordinate.setProperty(runtime, "heading", event.coordinate.heading);
+  coordinate.setProperty(runtime, "altitudeAccuracy", event.coordinate.altitudeAccuracy);
+  coordinate.setProperty(runtime, "isFromMockProvider", event.coordinate.isFromMockProvider);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto error = jsi::Object(runtime);
+  error.setProperty(runtime, "message", event.error.message);
+  payload.setProperty(runtime, "error", error);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMarkerEventEmitter::onCalloutPress(OnCalloutPress event) const {
+  dispatchEvent("calloutPress", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto frame = jsi::Object(runtime);
+  frame.setProperty(runtime, "x", event.frame.x);
+  frame.setProperty(runtime, "y", event.frame.y);
+  frame.setProperty(runtime, "width", event.frame.width);
+  frame.setProperty(runtime, "height", event.frame.height);
+  payload.setProperty(runtime, "frame", frame);
+}
+{
+  auto point = jsi::Object(runtime);
+  point.setProperty(runtime, "x", event.point.x);
+  point.setProperty(runtime, "y", event.point.y);
+  payload.setProperty(runtime, "point", point);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMarkerEventEmitter::onDeselect(OnDeselect event) const {
+  dispatchEvent("deselect", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMarkerEventEmitter::onDrag(OnDrag event) const {
+  dispatchEvent("drag", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMarkerEventEmitter::onDragEnd(OnDragEnd event) const {
+  dispatchEvent("dragEnd", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMarkerEventEmitter::onDragStart(OnDragStart event) const {
+  dispatchEvent("dragStart", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMarkerEventEmitter::onPress(OnPress event) const {
+  dispatchEvent("press", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsMarkerEventEmitter::onSelect(OnSelect event) const {
+  dispatchEvent("select", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsOverlayEventEmitter::onPress(OnPress event) const {
+  dispatchEvent("press", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+void RNMapsPolylineEventEmitter::onPress(OnPress event) const {
+  dispatchEvent("press", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "action", event.action);
+payload.setProperty(runtime, "id", event.id);
+{
+  auto coordinate = jsi::Object(runtime);
+  coordinate.setProperty(runtime, "latitude", event.coordinate.latitude);
+  coordinate.setProperty(runtime, "longitude", event.coordinate.longitude);
+  payload.setProperty(runtime, "coordinate", coordinate);
+}
+{
+  auto position = jsi::Object(runtime);
+  position.setProperty(runtime, "x", event.position.x);
+  position.setProperty(runtime, "y", event.position.y);
+  payload.setProperty(runtime, "position", position);
+}
+    return payload;
+  });
+}
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/EventEmitters.h b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/EventEmitters.h
new file mode 100644
index 0000000..fdc205e
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/EventEmitters.h
@@ -0,0 +1,860 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterH.js
+ */
+#pragma once
+
+#include <react/renderer/components/view/ViewEventEmitter.h>
+
+
+namespace facebook::react {
+class RNMapsCalloutEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPress {
+      std::string action;
+    std::string id;
+    OnPressCoordinate coordinate;
+    OnPressPosition position;
+    };
+  void onPress(OnPress value) const;
+};
+class RNMapsCircleEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPress {
+      std::string action;
+    std::string id;
+    OnPressCoordinate coordinate;
+    OnPressPosition position;
+    };
+  void onPress(OnPress value) const;
+};
+class RNMapsGoogleMapViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnIndoorBuildingFocused {
+      bool underground;
+    int activeLevelIndex;
+    std::string levels;
+    };
+
+  struct OnIndoorLevelActivated {
+      int activeLevelIndex;
+    std::string name;
+    std::string shortName;
+    };
+
+  struct OnKmlReady {
+      
+    };
+
+  struct OnLongPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnLongPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnLongPress {
+      OnLongPressCoordinate coordinate;
+    OnLongPressPosition position;
+    std::string action;
+    };
+
+  struct OnMapLoaded {
+      
+    };
+
+  struct OnMapReady {
+      
+    };
+
+  struct OnMarkerDeselectCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerDeselect {
+      std::string action;
+    std::string id;
+    OnMarkerDeselectCoordinate coordinate;
+    };
+
+  struct OnMarkerDragCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerDragPosition {
+      double x;
+    double y;
+    };
+
+  struct OnMarkerDrag {
+      OnMarkerDragCoordinate coordinate;
+    OnMarkerDragPosition position;
+    std::string id;
+    };
+
+  struct OnMarkerDragEndCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerDragEndPosition {
+      double x;
+    double y;
+    };
+
+  struct OnMarkerDragEnd {
+      OnMarkerDragEndCoordinate coordinate;
+    std::string id;
+    OnMarkerDragEndPosition position;
+    };
+
+  struct OnMarkerDragStartCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerDragStartPosition {
+      double x;
+    double y;
+    };
+
+  struct OnMarkerDragStart {
+      OnMarkerDragStartCoordinate coordinate;
+    std::string id;
+    OnMarkerDragStartPosition position;
+    };
+
+  struct OnMarkerPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnMarkerPress {
+      std::string action;
+    std::string id;
+    OnMarkerPressCoordinate coordinate;
+    OnMarkerPressPosition position;
+    };
+
+  struct OnMarkerSelectCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerSelect {
+      std::string action;
+    std::string id;
+    OnMarkerSelectCoordinate coordinate;
+    };
+
+  struct OnPanDragCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPanDragPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPanDrag {
+      OnPanDragCoordinate coordinate;
+    OnPanDragPosition position;
+    };
+
+  struct OnPoiClickCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPoiClickPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPoiClick {
+      std::string placeId;
+    std::string name;
+    OnPoiClickCoordinate coordinate;
+    OnPoiClickPosition position;
+    };
+
+  struct OnPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPress {
+      OnPressCoordinate coordinate;
+    OnPressPosition position;
+    std::string action;
+    };
+
+  struct OnRegionChangeStartRegion {
+      double latitude;
+    double longitude;
+    double latitudeDelta;
+    double longitudeDelta;
+    };
+
+  struct OnRegionChangeStart {
+      OnRegionChangeStartRegion region;
+    bool isGesture;
+    };
+
+  struct OnRegionChangeRegion {
+      double latitude;
+    double longitude;
+    double latitudeDelta;
+    double longitudeDelta;
+    };
+
+  struct OnRegionChange {
+      OnRegionChangeRegion region;
+    bool isGesture;
+    };
+
+  struct OnRegionChangeCompleteRegion {
+      double latitude;
+    double longitude;
+    double latitudeDelta;
+    double longitudeDelta;
+    };
+
+  struct OnRegionChangeComplete {
+      OnRegionChangeCompleteRegion region;
+    bool isGesture;
+    };
+
+  struct OnUserLocationChangeCoordinate {
+      double latitude;
+    double longitude;
+    double altitude;
+    double timestamp;
+    Float accuracy;
+    Float speed;
+    Float heading;
+    Float altitudeAccuracy;
+    bool isFromMockProvider;
+    };
+
+  struct OnUserLocationChangeError {
+      std::string message;
+    };
+
+  struct OnUserLocationChange {
+      OnUserLocationChangeCoordinate coordinate;
+    OnUserLocationChangeError error;
+    };
+  void onIndoorBuildingFocused(OnIndoorBuildingFocused value) const;
+
+  void onIndoorLevelActivated(OnIndoorLevelActivated value) const;
+
+  void onKmlReady(OnKmlReady value) const;
+
+  void onLongPress(OnLongPress value) const;
+
+  void onMapLoaded(OnMapLoaded value) const;
+
+  void onMapReady(OnMapReady value) const;
+
+  void onMarkerDeselect(OnMarkerDeselect value) const;
+
+  void onMarkerDrag(OnMarkerDrag value) const;
+
+  void onMarkerDragEnd(OnMarkerDragEnd value) const;
+
+  void onMarkerDragStart(OnMarkerDragStart value) const;
+
+  void onMarkerPress(OnMarkerPress value) const;
+
+  void onMarkerSelect(OnMarkerSelect value) const;
+
+  void onPanDrag(OnPanDrag value) const;
+
+  void onPoiClick(OnPoiClick value) const;
+
+  void onPress(OnPress value) const;
+
+  void onRegionChangeStart(OnRegionChangeStart value) const;
+
+  void onRegionChange(OnRegionChange value) const;
+
+  void onRegionChangeComplete(OnRegionChangeComplete value) const;
+
+  void onUserLocationChange(OnUserLocationChange value) const;
+};
+class RNMapsGooglePolygonEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPress {
+      std::string action;
+    std::string id;
+    OnPressCoordinate coordinate;
+    OnPressPosition position;
+    };
+  void onPress(OnPress value) const;
+};
+class RNMapsMapViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnCalloutPressFrame {
+      double x;
+    double y;
+    double width;
+    double height;
+    };
+
+  struct OnCalloutPressPoint {
+      double x;
+    double y;
+    };
+
+  struct OnCalloutPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnCalloutPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnCalloutPress {
+      std::string action;
+    OnCalloutPressFrame frame;
+    std::string id;
+    OnCalloutPressPoint point;
+    OnCalloutPressCoordinate coordinate;
+    OnCalloutPressPosition position;
+    };
+
+  struct OnDoublePressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnDoublePressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnDoublePress {
+      OnDoublePressCoordinate coordinate;
+    OnDoublePressPosition position;
+    };
+
+  struct OnIndoorBuildingFocusedIndoorBuilding {
+      bool underground;
+    int activeLevelIndex;
+    };
+
+  struct OnIndoorBuildingFocused {
+      OnIndoorBuildingFocusedIndoorBuilding IndoorBuilding;
+    };
+
+  struct OnIndoorLevelActivatedIndoorLevel {
+      int activeLevelIndex;
+    std::string name;
+    std::string shortName;
+    };
+
+  struct OnIndoorLevelActivated {
+      OnIndoorLevelActivatedIndoorLevel IndoorLevel;
+    };
+
+  struct OnKmlReady {
+      
+    };
+
+  struct OnLongPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnLongPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnLongPress {
+      OnLongPressCoordinate coordinate;
+    OnLongPressPosition position;
+    std::string action;
+    };
+
+  struct OnMapLoaded {
+      
+    };
+
+  struct OnMapReady {
+      
+    };
+
+  struct OnMarkerDeselectCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerDeselect {
+      std::string action;
+    std::string id;
+    OnMarkerDeselectCoordinate coordinate;
+    };
+
+  struct OnMarkerDragCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerDragPosition {
+      double x;
+    double y;
+    };
+
+  struct OnMarkerDrag {
+      OnMarkerDragCoordinate coordinate;
+    OnMarkerDragPosition position;
+    std::string id;
+    };
+
+  struct OnMarkerDragEndCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerDragEndPosition {
+      double x;
+    double y;
+    };
+
+  struct OnMarkerDragEnd {
+      OnMarkerDragEndCoordinate coordinate;
+    std::string id;
+    OnMarkerDragEndPosition position;
+    };
+
+  struct OnMarkerDragStartCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerDragStartPosition {
+      double x;
+    double y;
+    };
+
+  struct OnMarkerDragStart {
+      OnMarkerDragStartCoordinate coordinate;
+    std::string id;
+    OnMarkerDragStartPosition position;
+    };
+
+  struct OnMarkerPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnMarkerPress {
+      std::string action;
+    std::string id;
+    OnMarkerPressCoordinate coordinate;
+    OnMarkerPressPosition position;
+    };
+
+  struct OnMarkerSelectCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnMarkerSelect {
+      std::string action;
+    std::string id;
+    OnMarkerSelectCoordinate coordinate;
+    };
+
+  struct OnPanDragCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPanDragPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPanDrag {
+      OnPanDragCoordinate coordinate;
+    OnPanDragPosition position;
+    };
+
+  struct OnPoiClickCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPoiClickPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPoiClick {
+      std::string placeId;
+    std::string name;
+    OnPoiClickCoordinate coordinate;
+    OnPoiClickPosition position;
+    };
+
+  struct OnPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPress {
+      OnPressCoordinate coordinate;
+    OnPressPosition position;
+    std::string action;
+    };
+
+  struct OnRegionChangeStartRegion {
+      double latitude;
+    double longitude;
+    double latitudeDelta;
+    double longitudeDelta;
+    };
+
+  struct OnRegionChangeStart {
+      OnRegionChangeStartRegion region;
+    bool isGesture;
+    };
+
+  struct OnRegionChangeRegion {
+      double latitude;
+    double longitude;
+    double latitudeDelta;
+    double longitudeDelta;
+    };
+
+  struct OnRegionChange {
+      OnRegionChangeRegion region;
+    bool isGesture;
+    };
+
+  struct OnRegionChangeCompleteRegion {
+      double latitude;
+    double longitude;
+    double latitudeDelta;
+    double longitudeDelta;
+    };
+
+  struct OnRegionChangeComplete {
+      OnRegionChangeCompleteRegion region;
+    bool isGesture;
+    };
+
+  struct OnUserLocationChangeCoordinate {
+      double latitude;
+    double longitude;
+    double altitude;
+    double timestamp;
+    Float accuracy;
+    Float speed;
+    Float heading;
+    Float altitudeAccuracy;
+    bool isFromMockProvider;
+    };
+
+  struct OnUserLocationChangeError {
+      std::string message;
+    };
+
+  struct OnUserLocationChange {
+      OnUserLocationChangeCoordinate coordinate;
+    OnUserLocationChangeError error;
+    };
+  void onCalloutPress(OnCalloutPress value) const;
+
+  void onDoublePress(OnDoublePress value) const;
+
+  void onIndoorBuildingFocused(OnIndoorBuildingFocused value) const;
+
+  void onIndoorLevelActivated(OnIndoorLevelActivated value) const;
+
+  void onKmlReady(OnKmlReady value) const;
+
+  void onLongPress(OnLongPress value) const;
+
+  void onMapLoaded(OnMapLoaded value) const;
+
+  void onMapReady(OnMapReady value) const;
+
+  void onMarkerDeselect(OnMarkerDeselect value) const;
+
+  void onMarkerDrag(OnMarkerDrag value) const;
+
+  void onMarkerDragEnd(OnMarkerDragEnd value) const;
+
+  void onMarkerDragStart(OnMarkerDragStart value) const;
+
+  void onMarkerPress(OnMarkerPress value) const;
+
+  void onMarkerSelect(OnMarkerSelect value) const;
+
+  void onPanDrag(OnPanDrag value) const;
+
+  void onPoiClick(OnPoiClick value) const;
+
+  void onPress(OnPress value) const;
+
+  void onRegionChangeStart(OnRegionChangeStart value) const;
+
+  void onRegionChange(OnRegionChange value) const;
+
+  void onRegionChangeComplete(OnRegionChangeComplete value) const;
+
+  void onUserLocationChange(OnUserLocationChange value) const;
+};
+class RNMapsMarkerEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnCalloutPressFrame {
+      double x;
+    double y;
+    double width;
+    double height;
+    };
+
+  struct OnCalloutPressPoint {
+      double x;
+    double y;
+    };
+
+  struct OnCalloutPress {
+      std::string action;
+    std::string id;
+    OnCalloutPressFrame frame;
+    OnCalloutPressPoint point;
+    };
+
+  struct OnDeselectCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnDeselectPosition {
+      double x;
+    double y;
+    };
+
+  struct OnDeselect {
+      std::string action;
+    std::string id;
+    OnDeselectCoordinate coordinate;
+    OnDeselectPosition position;
+    };
+
+  struct OnDragCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnDrag {
+      std::string id;
+    OnDragCoordinate coordinate;
+    };
+
+  struct OnDragEndCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnDragEnd {
+      std::string id;
+    OnDragEndCoordinate coordinate;
+    };
+
+  struct OnDragStartCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnDragStart {
+      std::string id;
+    OnDragStartCoordinate coordinate;
+    };
+
+  struct OnPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPress {
+      std::string action;
+    std::string id;
+    OnPressCoordinate coordinate;
+    OnPressPosition position;
+    };
+
+  struct OnSelectCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnSelectPosition {
+      double x;
+    double y;
+    };
+
+  struct OnSelect {
+      std::string action;
+    std::string id;
+    OnSelectCoordinate coordinate;
+    OnSelectPosition position;
+    };
+  void onCalloutPress(OnCalloutPress value) const;
+
+  void onDeselect(OnDeselect value) const;
+
+  void onDrag(OnDrag value) const;
+
+  void onDragEnd(OnDragEnd value) const;
+
+  void onDragStart(OnDragStart value) const;
+
+  void onPress(OnPress value) const;
+
+  void onSelect(OnSelect value) const;
+};
+class RNMapsOverlayEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPress {
+      std::string action;
+    std::string id;
+    OnPressCoordinate coordinate;
+    OnPressPosition position;
+    };
+  void onPress(OnPress value) const;
+};
+class RNMapsPolylineEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnPressCoordinate {
+      double latitude;
+    double longitude;
+    };
+
+  struct OnPressPosition {
+      double x;
+    double y;
+    };
+
+  struct OnPress {
+      std::string action;
+    std::string id;
+    OnPressCoordinate coordinate;
+    OnPressPosition position;
+    };
+  void onPress(OnPress value) const;
+};
+class RNMapsUrlTileEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class RNMapsWMSTileEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/Props.cpp b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/Props.cpp
new file mode 100644
index 0000000..e157ffd
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/Props.cpp
@@ -0,0 +1,1019 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsCpp.js
+ */
+
+#include "Props.h"
+#include <react/renderer/components/image/conversions.h>
+#include <react/renderer/core/PropsParserContext.h>
+#include <react/renderer/core/propsConversions.h>
+
+namespace facebook::react {
+
+RNMapsCalloutProps::RNMapsCalloutProps(
+    const PropsParserContext &context,
+    const RNMapsCalloutProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    alphaHitTest(convertRawProp(context, rawProps, "alphaHitTest", sourceProps.alphaHitTest, {false})),
+    tooltip(convertRawProp(context, rawProps, "tooltip", sourceProps.tooltip, {false})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsCalloutProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsCallout";
+}
+
+folly::dynamic RNMapsCalloutProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsCalloutProps();
+  const RNMapsCalloutProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsCalloutProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if (alphaHitTest != oldProps->alphaHitTest) {
+    result["alphaHitTest"] = alphaHitTest;
+  }
+    
+  if (tooltip != oldProps->tooltip) {
+    result["tooltip"] = tooltip;
+  }
+  return result;
+}
+#endif
+RNMapsCircleProps::RNMapsCircleProps(
+    const PropsParserContext &context,
+    const RNMapsCircleProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    center(convertRawProp(context, rawProps, "center", sourceProps.center, {})),
+    fillColor(convertRawProp(context, rawProps, "fillColor", sourceProps.fillColor, {})),
+    radius(convertRawProp(context, rawProps, "radius", sourceProps.radius, {0.0})),
+    strokeColor(convertRawProp(context, rawProps, "strokeColor", sourceProps.strokeColor, {})),
+    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {1.0})),
+    tappable(convertRawProp(context, rawProps, "tappable", sourceProps.tappable, {false})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsCircleProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsCircle";
+}
+
+folly::dynamic RNMapsCircleProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsCircleProps();
+  const RNMapsCircleProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsCircleProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if (center != oldProps->center) {
+    result["center"] = toDynamic(center);
+  }
+    
+  if (fillColor != oldProps->fillColor) {
+    result["fillColor"] = *fillColor;
+  }
+    
+  if ((radius != oldProps->radius) && !(std::isnan(radius) && std::isnan(oldProps->radius))) {
+    result["radius"] = radius;
+  }
+    
+  if (strokeColor != oldProps->strokeColor) {
+    result["strokeColor"] = *strokeColor;
+  }
+    
+  if ((strokeWidth != oldProps->strokeWidth) && !(std::isnan(strokeWidth) && std::isnan(oldProps->strokeWidth))) {
+    result["strokeWidth"] = strokeWidth;
+  }
+    
+  if (tappable != oldProps->tappable) {
+    result["tappable"] = tappable;
+  }
+  return result;
+}
+#endif
+RNMapsGoogleMapViewProps::RNMapsGoogleMapViewProps(
+    const PropsParserContext &context,
+    const RNMapsGoogleMapViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    camera(convertRawProp(context, rawProps, "camera", sourceProps.camera, {})),
+    initialCamera(convertRawProp(context, rawProps, "initialCamera", sourceProps.initialCamera, {})),
+    initialRegion(convertRawProp(context, rawProps, "initialRegion", sourceProps.initialRegion, {})),
+    kmlSrc(convertRawProp(context, rawProps, "kmlSrc", sourceProps.kmlSrc, {})),
+    googleMapId(convertRawProp(context, rawProps, "googleMapId", sourceProps.googleMapId, {})),
+    loadingBackgroundColor(convertRawProp(context, rawProps, "loadingBackgroundColor", sourceProps.loadingBackgroundColor, {})),
+    mapPadding(convertRawProp(context, rawProps, "mapPadding", sourceProps.mapPadding, {})),
+    mapType(convertRawProp(context, rawProps, "mapType", sourceProps.mapType, {RNMapsGoogleMapViewMapType::Standard})),
+    maxZoom(convertRawProp(context, rawProps, "maxZoom", sourceProps.maxZoom, {0.0})),
+    minZoom(convertRawProp(context, rawProps, "minZoom", sourceProps.minZoom, {0.0})),
+    paddingAdjustmentBehavior(convertRawProp(context, rawProps, "paddingAdjustmentBehavior", sourceProps.paddingAdjustmentBehavior, {RNMapsGoogleMapViewPaddingAdjustmentBehavior::Never})),
+    pitchEnabled(convertRawProp(context, rawProps, "pitchEnabled", sourceProps.pitchEnabled, {true})),
+    region(convertRawProp(context, rawProps, "region", sourceProps.region, {})),
+    rotateEnabled(convertRawProp(context, rawProps, "rotateEnabled", sourceProps.rotateEnabled, {true})),
+    scrollDuringRotateOrZoomEnabled(convertRawProp(context, rawProps, "scrollDuringRotateOrZoomEnabled", sourceProps.scrollDuringRotateOrZoomEnabled, {true})),
+    scrollEnabled(convertRawProp(context, rawProps, "scrollEnabled", sourceProps.scrollEnabled, {true})),
+    showsBuildings(convertRawProp(context, rawProps, "showsBuildings", sourceProps.showsBuildings, {true})),
+    showsCompass(convertRawProp(context, rawProps, "showsCompass", sourceProps.showsCompass, {false})),
+    showsIndoorLevelPicker(convertRawProp(context, rawProps, "showsIndoorLevelPicker", sourceProps.showsIndoorLevelPicker, {false})),
+    showsIndoors(convertRawProp(context, rawProps, "showsIndoors", sourceProps.showsIndoors, {true})),
+    showsMyLocationButton(convertRawProp(context, rawProps, "showsMyLocationButton", sourceProps.showsMyLocationButton, {false})),
+    showsScale(convertRawProp(context, rawProps, "showsScale", sourceProps.showsScale, {false})),
+    showsTraffic(convertRawProp(context, rawProps, "showsTraffic", sourceProps.showsTraffic, {false})),
+    showsUserLocation(convertRawProp(context, rawProps, "showsUserLocation", sourceProps.showsUserLocation, {false})),
+    userInterfaceStyle(convertRawProp(context, rawProps, "userInterfaceStyle", sourceProps.userInterfaceStyle, {RNMapsGoogleMapViewUserInterfaceStyle::System})),
+    customMapStyleString(convertRawProp(context, rawProps, "customMapStyleString", sourceProps.customMapStyleString, {})),
+    userLocationCalloutEnabled(convertRawProp(context, rawProps, "userLocationCalloutEnabled", sourceProps.userLocationCalloutEnabled, {false})),
+    userLocationFastestInterval(convertRawProp(context, rawProps, "userLocationFastestInterval", sourceProps.userLocationFastestInterval, {0})),
+    userLocationPriority(convertRawProp(context, rawProps, "userLocationPriority", sourceProps.userLocationPriority, {RNMapsGoogleMapViewUserLocationPriority::High})),
+    userLocationUpdateInterval(convertRawProp(context, rawProps, "userLocationUpdateInterval", sourceProps.userLocationUpdateInterval, {0})),
+    zoomControlEnabled(convertRawProp(context, rawProps, "zoomControlEnabled", sourceProps.zoomControlEnabled, {false})),
+    zoomEnabled(convertRawProp(context, rawProps, "zoomEnabled", sourceProps.zoomEnabled, {true})),
+    zoomTapEnabled(convertRawProp(context, rawProps, "zoomTapEnabled", sourceProps.zoomTapEnabled, {true})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsGoogleMapViewProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsGoogleMapView";
+}
+
+folly::dynamic RNMapsGoogleMapViewProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsGoogleMapViewProps();
+  const RNMapsGoogleMapViewProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsGoogleMapViewProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if (camera != oldProps->camera) {
+    result["camera"] = toDynamic(camera);
+  }
+    
+  if (initialCamera != oldProps->initialCamera) {
+    result["initialCamera"] = toDynamic(initialCamera);
+  }
+    
+  if (initialRegion != oldProps->initialRegion) {
+    result["initialRegion"] = toDynamic(initialRegion);
+  }
+    
+  if (kmlSrc != oldProps->kmlSrc) {
+    result["kmlSrc"] = kmlSrc;
+  }
+    
+  if (googleMapId != oldProps->googleMapId) {
+    result["googleMapId"] = googleMapId;
+  }
+    
+  if (loadingBackgroundColor != oldProps->loadingBackgroundColor) {
+    result["loadingBackgroundColor"] = *loadingBackgroundColor;
+  }
+    
+  if (mapPadding != oldProps->mapPadding) {
+    result["mapPadding"] = toDynamic(mapPadding);
+  }
+    
+  if (mapType != oldProps->mapType) {
+    result["mapType"] = toDynamic(mapType);
+  }
+    
+  if ((maxZoom != oldProps->maxZoom) && !(std::isnan(maxZoom) && std::isnan(oldProps->maxZoom))) {
+    result["maxZoom"] = maxZoom;
+  }
+    
+  if ((minZoom != oldProps->minZoom) && !(std::isnan(minZoom) && std::isnan(oldProps->minZoom))) {
+    result["minZoom"] = minZoom;
+  }
+    
+  if (paddingAdjustmentBehavior != oldProps->paddingAdjustmentBehavior) {
+    result["paddingAdjustmentBehavior"] = toDynamic(paddingAdjustmentBehavior);
+  }
+    
+  if (pitchEnabled != oldProps->pitchEnabled) {
+    result["pitchEnabled"] = pitchEnabled;
+  }
+    
+  if (region != oldProps->region) {
+    result["region"] = toDynamic(region);
+  }
+    
+  if (rotateEnabled != oldProps->rotateEnabled) {
+    result["rotateEnabled"] = rotateEnabled;
+  }
+    
+  if (scrollDuringRotateOrZoomEnabled != oldProps->scrollDuringRotateOrZoomEnabled) {
+    result["scrollDuringRotateOrZoomEnabled"] = scrollDuringRotateOrZoomEnabled;
+  }
+    
+  if (scrollEnabled != oldProps->scrollEnabled) {
+    result["scrollEnabled"] = scrollEnabled;
+  }
+    
+  if (showsBuildings != oldProps->showsBuildings) {
+    result["showsBuildings"] = showsBuildings;
+  }
+    
+  if (showsCompass != oldProps->showsCompass) {
+    result["showsCompass"] = showsCompass;
+  }
+    
+  if (showsIndoorLevelPicker != oldProps->showsIndoorLevelPicker) {
+    result["showsIndoorLevelPicker"] = showsIndoorLevelPicker;
+  }
+    
+  if (showsIndoors != oldProps->showsIndoors) {
+    result["showsIndoors"] = showsIndoors;
+  }
+    
+  if (showsMyLocationButton != oldProps->showsMyLocationButton) {
+    result["showsMyLocationButton"] = showsMyLocationButton;
+  }
+    
+  if (showsScale != oldProps->showsScale) {
+    result["showsScale"] = showsScale;
+  }
+    
+  if (showsTraffic != oldProps->showsTraffic) {
+    result["showsTraffic"] = showsTraffic;
+  }
+    
+  if (showsUserLocation != oldProps->showsUserLocation) {
+    result["showsUserLocation"] = showsUserLocation;
+  }
+    
+  if (userInterfaceStyle != oldProps->userInterfaceStyle) {
+    result["userInterfaceStyle"] = toDynamic(userInterfaceStyle);
+  }
+    
+  if (customMapStyleString != oldProps->customMapStyleString) {
+    result["customMapStyleString"] = customMapStyleString;
+  }
+    
+  if (userLocationCalloutEnabled != oldProps->userLocationCalloutEnabled) {
+    result["userLocationCalloutEnabled"] = userLocationCalloutEnabled;
+  }
+    
+  if (userLocationFastestInterval != oldProps->userLocationFastestInterval) {
+    result["userLocationFastestInterval"] = userLocationFastestInterval;
+  }
+    
+  if (userLocationPriority != oldProps->userLocationPriority) {
+    result["userLocationPriority"] = toDynamic(userLocationPriority);
+  }
+    
+  if (userLocationUpdateInterval != oldProps->userLocationUpdateInterval) {
+    result["userLocationUpdateInterval"] = userLocationUpdateInterval;
+  }
+    
+  if (zoomControlEnabled != oldProps->zoomControlEnabled) {
+    result["zoomControlEnabled"] = zoomControlEnabled;
+  }
+    
+  if (zoomEnabled != oldProps->zoomEnabled) {
+    result["zoomEnabled"] = zoomEnabled;
+  }
+    
+  if (zoomTapEnabled != oldProps->zoomTapEnabled) {
+    result["zoomTapEnabled"] = zoomTapEnabled;
+  }
+  return result;
+}
+#endif
+RNMapsGooglePolygonProps::RNMapsGooglePolygonProps(
+    const PropsParserContext &context,
+    const RNMapsGooglePolygonProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    coordinates(convertRawProp(context, rawProps, "coordinates", sourceProps.coordinates, {})),
+    fillColor(convertRawProp(context, rawProps, "fillColor", sourceProps.fillColor, {})),
+    strokeColor(convertRawProp(context, rawProps, "strokeColor", sourceProps.strokeColor, {})),
+    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {1.0})),
+    geodesic(convertRawProp(context, rawProps, "geodesic", sourceProps.geodesic, {false})),
+    holes(convertRawProp(context, rawProps, "holes", sourceProps.holes, {})),
+    tappable(convertRawProp(context, rawProps, "tappable", sourceProps.tappable, {false})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsGooglePolygonProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsGooglePolygon";
+}
+
+folly::dynamic RNMapsGooglePolygonProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsGooglePolygonProps();
+  const RNMapsGooglePolygonProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsGooglePolygonProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if (coordinates != oldProps->coordinates) {
+    result["coordinates"] = toDynamic(coordinates);
+  }
+    
+  if (fillColor != oldProps->fillColor) {
+    result["fillColor"] = *fillColor;
+  }
+    
+  if (strokeColor != oldProps->strokeColor) {
+    result["strokeColor"] = *strokeColor;
+  }
+    
+  if ((strokeWidth != oldProps->strokeWidth) && !(std::isnan(strokeWidth) && std::isnan(oldProps->strokeWidth))) {
+    result["strokeWidth"] = strokeWidth;
+  }
+    
+  if (geodesic != oldProps->geodesic) {
+    result["geodesic"] = geodesic;
+  }
+    
+  if (holes != oldProps->holes) {
+    result["holes"] = toDynamic(holes);
+  }
+    
+  if (tappable != oldProps->tappable) {
+    result["tappable"] = tappable;
+  }
+  return result;
+}
+#endif
+RNMapsMapViewProps::RNMapsMapViewProps(
+    const PropsParserContext &context,
+    const RNMapsMapViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    cacheEnabled(convertRawProp(context, rawProps, "cacheEnabled", sourceProps.cacheEnabled, {false})),
+    camera(convertRawProp(context, rawProps, "camera", sourceProps.camera, {})),
+    compassOffset(convertRawProp(context, rawProps, "compassOffset", sourceProps.compassOffset, {})),
+    followsUserLocation(convertRawProp(context, rawProps, "followsUserLocation", sourceProps.followsUserLocation, {false})),
+    poiClickEnabled(convertRawProp(context, rawProps, "poiClickEnabled", sourceProps.poiClickEnabled, {false})),
+    initialCamera(convertRawProp(context, rawProps, "initialCamera", sourceProps.initialCamera, {})),
+    initialRegion(convertRawProp(context, rawProps, "initialRegion", sourceProps.initialRegion, {})),
+    kmlSrc(convertRawProp(context, rawProps, "kmlSrc", sourceProps.kmlSrc, {})),
+    legalLabelInsets(convertRawProp(context, rawProps, "legalLabelInsets", sourceProps.legalLabelInsets, {})),
+    liteMode(convertRawProp(context, rawProps, "liteMode", sourceProps.liteMode, {false})),
+    googleMapId(convertRawProp(context, rawProps, "googleMapId", sourceProps.googleMapId, {})),
+    googleRenderer(convertRawProp(context, rawProps, "googleRenderer", sourceProps.googleRenderer, {RNMapsMapViewGoogleRenderer::LATEST})),
+    loadingBackgroundColor(convertRawProp(context, rawProps, "loadingBackgroundColor", sourceProps.loadingBackgroundColor, {})),
+    loadingEnabled(convertRawProp(context, rawProps, "loadingEnabled", sourceProps.loadingEnabled, {false})),
+    loadingIndicatorColor(convertRawProp(context, rawProps, "loadingIndicatorColor", sourceProps.loadingIndicatorColor, {})),
+    mapPadding(convertRawProp(context, rawProps, "mapPadding", sourceProps.mapPadding, {})),
+    mapType(convertRawProp(context, rawProps, "mapType", sourceProps.mapType, {RNMapsMapViewMapType::Standard})),
+    maxDelta(convertRawProp(context, rawProps, "maxDelta", sourceProps.maxDelta, {0.0})),
+    maxZoom(convertRawProp(context, rawProps, "maxZoom", sourceProps.maxZoom, {0.0})),
+    minDelta(convertRawProp(context, rawProps, "minDelta", sourceProps.minDelta, {0.0})),
+    minZoom(convertRawProp(context, rawProps, "minZoom", sourceProps.minZoom, {0.0})),
+    moveOnMarkerPress(convertRawProp(context, rawProps, "moveOnMarkerPress", sourceProps.moveOnMarkerPress, {true})),
+    handlePanDrag(convertRawProp(context, rawProps, "handlePanDrag", sourceProps.handlePanDrag, {false})),
+    paddingAdjustmentBehavior(convertRawProp(context, rawProps, "paddingAdjustmentBehavior", sourceProps.paddingAdjustmentBehavior, {RNMapsMapViewPaddingAdjustmentBehavior::Never})),
+    pitchEnabled(convertRawProp(context, rawProps, "pitchEnabled", sourceProps.pitchEnabled, {true})),
+    region(convertRawProp(context, rawProps, "region", sourceProps.region, {})),
+    rotateEnabled(convertRawProp(context, rawProps, "rotateEnabled", sourceProps.rotateEnabled, {true})),
+    scrollDuringRotateOrZoomEnabled(convertRawProp(context, rawProps, "scrollDuringRotateOrZoomEnabled", sourceProps.scrollDuringRotateOrZoomEnabled, {true})),
+    scrollEnabled(convertRawProp(context, rawProps, "scrollEnabled", sourceProps.scrollEnabled, {true})),
+    showsBuildings(convertRawProp(context, rawProps, "showsBuildings", sourceProps.showsBuildings, {true})),
+    showsCompass(convertRawProp(context, rawProps, "showsCompass", sourceProps.showsCompass, {true})),
+    showsIndoorLevelPicker(convertRawProp(context, rawProps, "showsIndoorLevelPicker", sourceProps.showsIndoorLevelPicker, {false})),
+    showsIndoors(convertRawProp(context, rawProps, "showsIndoors", sourceProps.showsIndoors, {true})),
+    showsPointsOfInterests(convertRawProp(context, rawProps, "showsPointsOfInterests", sourceProps.showsPointsOfInterests, {true})),
+    pointsOfInterestFilter(convertRawProp(context, rawProps, "pointsOfInterestFilter", sourceProps.pointsOfInterestFilter, {})),
+    showsMyLocationButton(convertRawProp(context, rawProps, "showsMyLocationButton", sourceProps.showsMyLocationButton, {false})),
+    showsScale(convertRawProp(context, rawProps, "showsScale", sourceProps.showsScale, {false})),
+    showsUserLocation(convertRawProp(context, rawProps, "showsUserLocation", sourceProps.showsUserLocation, {false})),
+    tintColor(convertRawProp(context, rawProps, "tintColor", sourceProps.tintColor, {})),
+    toolbarEnabled(convertRawProp(context, rawProps, "toolbarEnabled", sourceProps.toolbarEnabled, {true})),
+    userInterfaceStyle(convertRawProp(context, rawProps, "userInterfaceStyle", sourceProps.userInterfaceStyle, {RNMapsMapViewUserInterfaceStyle::System})),
+    customMapStyleString(convertRawProp(context, rawProps, "customMapStyleString", sourceProps.customMapStyleString, {})),
+    userLocationAnnotationTitle(convertRawProp(context, rawProps, "userLocationAnnotationTitle", sourceProps.userLocationAnnotationTitle, {})),
+    userLocationCalloutEnabled(convertRawProp(context, rawProps, "userLocationCalloutEnabled", sourceProps.userLocationCalloutEnabled, {false})),
+    userLocationFastestInterval(convertRawProp(context, rawProps, "userLocationFastestInterval", sourceProps.userLocationFastestInterval, {5000})),
+    userLocationPriority(convertRawProp(context, rawProps, "userLocationPriority", sourceProps.userLocationPriority, {RNMapsMapViewUserLocationPriority::High})),
+    userLocationUpdateInterval(convertRawProp(context, rawProps, "userLocationUpdateInterval", sourceProps.userLocationUpdateInterval, {5000})),
+    zoomControlEnabled(convertRawProp(context, rawProps, "zoomControlEnabled", sourceProps.zoomControlEnabled, {true})),
+    zoomEnabled(convertRawProp(context, rawProps, "zoomEnabled", sourceProps.zoomEnabled, {true})),
+    showsTraffic(convertRawProp(context, rawProps, "showsTraffic", sourceProps.showsTraffic, {false})),
+    zoomTapEnabled(convertRawProp(context, rawProps, "zoomTapEnabled", sourceProps.zoomTapEnabled, {true})),
+    cameraZoomRange(convertRawProp(context, rawProps, "cameraZoomRange", sourceProps.cameraZoomRange, {})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsMapViewProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsMapView";
+}
+
+folly::dynamic RNMapsMapViewProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsMapViewProps();
+  const RNMapsMapViewProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsMapViewProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if (cacheEnabled != oldProps->cacheEnabled) {
+    result["cacheEnabled"] = cacheEnabled;
+  }
+    
+  if (camera != oldProps->camera) {
+    result["camera"] = toDynamic(camera);
+  }
+    
+  if (compassOffset != oldProps->compassOffset) {
+    result["compassOffset"] = toDynamic(compassOffset);
+  }
+    
+  if (followsUserLocation != oldProps->followsUserLocation) {
+    result["followsUserLocation"] = followsUserLocation;
+  }
+    
+  if (poiClickEnabled != oldProps->poiClickEnabled) {
+    result["poiClickEnabled"] = poiClickEnabled;
+  }
+    
+  if (initialCamera != oldProps->initialCamera) {
+    result["initialCamera"] = toDynamic(initialCamera);
+  }
+    
+  if (initialRegion != oldProps->initialRegion) {
+    result["initialRegion"] = toDynamic(initialRegion);
+  }
+    
+  if (kmlSrc != oldProps->kmlSrc) {
+    result["kmlSrc"] = kmlSrc;
+  }
+    
+  if (legalLabelInsets != oldProps->legalLabelInsets) {
+    result["legalLabelInsets"] = toDynamic(legalLabelInsets);
+  }
+    
+  if (liteMode != oldProps->liteMode) {
+    result["liteMode"] = liteMode;
+  }
+    
+  if (googleMapId != oldProps->googleMapId) {
+    result["googleMapId"] = googleMapId;
+  }
+    
+  if (googleRenderer != oldProps->googleRenderer) {
+    result["googleRenderer"] = toDynamic(googleRenderer);
+  }
+    
+  if (loadingBackgroundColor != oldProps->loadingBackgroundColor) {
+    result["loadingBackgroundColor"] = *loadingBackgroundColor;
+  }
+    
+  if (loadingEnabled != oldProps->loadingEnabled) {
+    result["loadingEnabled"] = loadingEnabled;
+  }
+    
+  if (loadingIndicatorColor != oldProps->loadingIndicatorColor) {
+    result["loadingIndicatorColor"] = *loadingIndicatorColor;
+  }
+    
+  if (mapPadding != oldProps->mapPadding) {
+    result["mapPadding"] = toDynamic(mapPadding);
+  }
+    
+  if (mapType != oldProps->mapType) {
+    result["mapType"] = toDynamic(mapType);
+  }
+    
+  if ((maxDelta != oldProps->maxDelta) && !(std::isnan(maxDelta) && std::isnan(oldProps->maxDelta))) {
+    result["maxDelta"] = maxDelta;
+  }
+    
+  if ((maxZoom != oldProps->maxZoom) && !(std::isnan(maxZoom) && std::isnan(oldProps->maxZoom))) {
+    result["maxZoom"] = maxZoom;
+  }
+    
+  if ((minDelta != oldProps->minDelta) && !(std::isnan(minDelta) && std::isnan(oldProps->minDelta))) {
+    result["minDelta"] = minDelta;
+  }
+    
+  if ((minZoom != oldProps->minZoom) && !(std::isnan(minZoom) && std::isnan(oldProps->minZoom))) {
+    result["minZoom"] = minZoom;
+  }
+    
+  if (moveOnMarkerPress != oldProps->moveOnMarkerPress) {
+    result["moveOnMarkerPress"] = moveOnMarkerPress;
+  }
+    
+  if (handlePanDrag != oldProps->handlePanDrag) {
+    result["handlePanDrag"] = handlePanDrag;
+  }
+    
+  if (paddingAdjustmentBehavior != oldProps->paddingAdjustmentBehavior) {
+    result["paddingAdjustmentBehavior"] = toDynamic(paddingAdjustmentBehavior);
+  }
+    
+  if (pitchEnabled != oldProps->pitchEnabled) {
+    result["pitchEnabled"] = pitchEnabled;
+  }
+    
+  if (region != oldProps->region) {
+    result["region"] = toDynamic(region);
+  }
+    
+  if (rotateEnabled != oldProps->rotateEnabled) {
+    result["rotateEnabled"] = rotateEnabled;
+  }
+    
+  if (scrollDuringRotateOrZoomEnabled != oldProps->scrollDuringRotateOrZoomEnabled) {
+    result["scrollDuringRotateOrZoomEnabled"] = scrollDuringRotateOrZoomEnabled;
+  }
+    
+  if (scrollEnabled != oldProps->scrollEnabled) {
+    result["scrollEnabled"] = scrollEnabled;
+  }
+    
+  if (showsBuildings != oldProps->showsBuildings) {
+    result["showsBuildings"] = showsBuildings;
+  }
+    
+  if (showsCompass != oldProps->showsCompass) {
+    result["showsCompass"] = showsCompass;
+  }
+    
+  if (showsIndoorLevelPicker != oldProps->showsIndoorLevelPicker) {
+    result["showsIndoorLevelPicker"] = showsIndoorLevelPicker;
+  }
+    
+  if (showsIndoors != oldProps->showsIndoors) {
+    result["showsIndoors"] = showsIndoors;
+  }
+    
+  if (showsPointsOfInterests != oldProps->showsPointsOfInterests) {
+    result["showsPointsOfInterests"] = showsPointsOfInterests;
+  }
+    
+  if (pointsOfInterestFilter != oldProps->pointsOfInterestFilter) {
+    result["pointsOfInterestFilter"] = toDynamic(pointsOfInterestFilter);
+  }
+    
+  if (showsMyLocationButton != oldProps->showsMyLocationButton) {
+    result["showsMyLocationButton"] = showsMyLocationButton;
+  }
+    
+  if (showsScale != oldProps->showsScale) {
+    result["showsScale"] = showsScale;
+  }
+    
+  if (showsUserLocation != oldProps->showsUserLocation) {
+    result["showsUserLocation"] = showsUserLocation;
+  }
+    
+  if (tintColor != oldProps->tintColor) {
+    result["tintColor"] = *tintColor;
+  }
+    
+  if (toolbarEnabled != oldProps->toolbarEnabled) {
+    result["toolbarEnabled"] = toolbarEnabled;
+  }
+    
+  if (userInterfaceStyle != oldProps->userInterfaceStyle) {
+    result["userInterfaceStyle"] = toDynamic(userInterfaceStyle);
+  }
+    
+  if (customMapStyleString != oldProps->customMapStyleString) {
+    result["customMapStyleString"] = customMapStyleString;
+  }
+    
+  if (userLocationAnnotationTitle != oldProps->userLocationAnnotationTitle) {
+    result["userLocationAnnotationTitle"] = userLocationAnnotationTitle;
+  }
+    
+  if (userLocationCalloutEnabled != oldProps->userLocationCalloutEnabled) {
+    result["userLocationCalloutEnabled"] = userLocationCalloutEnabled;
+  }
+    
+  if (userLocationFastestInterval != oldProps->userLocationFastestInterval) {
+    result["userLocationFastestInterval"] = userLocationFastestInterval;
+  }
+    
+  if (userLocationPriority != oldProps->userLocationPriority) {
+    result["userLocationPriority"] = toDynamic(userLocationPriority);
+  }
+    
+  if (userLocationUpdateInterval != oldProps->userLocationUpdateInterval) {
+    result["userLocationUpdateInterval"] = userLocationUpdateInterval;
+  }
+    
+  if (zoomControlEnabled != oldProps->zoomControlEnabled) {
+    result["zoomControlEnabled"] = zoomControlEnabled;
+  }
+    
+  if (zoomEnabled != oldProps->zoomEnabled) {
+    result["zoomEnabled"] = zoomEnabled;
+  }
+    
+  if (showsTraffic != oldProps->showsTraffic) {
+    result["showsTraffic"] = showsTraffic;
+  }
+    
+  if (zoomTapEnabled != oldProps->zoomTapEnabled) {
+    result["zoomTapEnabled"] = zoomTapEnabled;
+  }
+    
+  if (cameraZoomRange != oldProps->cameraZoomRange) {
+    result["cameraZoomRange"] = toDynamic(cameraZoomRange);
+  }
+  return result;
+}
+#endif
+RNMapsMarkerProps::RNMapsMarkerProps(
+    const PropsParserContext &context,
+    const RNMapsMarkerProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    anchor(convertRawProp(context, rawProps, "anchor", sourceProps.anchor, {})),
+    calloutAnchor(convertRawProp(context, rawProps, "calloutAnchor", sourceProps.calloutAnchor, {})),
+    image(convertRawProp(context, rawProps, "image", sourceProps.image, {})),
+    calloutOffset(convertRawProp(context, rawProps, "calloutOffset", sourceProps.calloutOffset, {})),
+    displayPriority(convertRawProp(context, rawProps, "displayPriority", sourceProps.displayPriority, {RNMapsMarkerDisplayPriority::Required})),
+    centerOffset(convertRawProp(context, rawProps, "centerOffset", sourceProps.centerOffset, {})),
+    coordinate(convertRawProp(context, rawProps, "coordinate", sourceProps.coordinate, {})),
+    description(convertRawProp(context, rawProps, "description", sourceProps.description, {})),
+    draggable(convertRawProp(context, rawProps, "draggable", sourceProps.draggable, {false})),
+    title(convertRawProp(context, rawProps, "title", sourceProps.title, {})),
+    tracksViewChanges(convertRawProp(context, rawProps, "tracksViewChanges", sourceProps.tracksViewChanges, {true})),
+    identifier(convertRawProp(context, rawProps, "identifier", sourceProps.identifier, {})),
+    isPreselected(convertRawProp(context, rawProps, "isPreselected", sourceProps.isPreselected, {false})),
+    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
+    pinColor(convertRawProp(context, rawProps, "pinColor", sourceProps.pinColor, {})),
+    titleVisibility(convertRawProp(context, rawProps, "titleVisibility", sourceProps.titleVisibility, {RNMapsMarkerTitleVisibility::Visible})),
+    subtitleVisibility(convertRawProp(context, rawProps, "subtitleVisibility", sourceProps.subtitleVisibility, {RNMapsMarkerSubtitleVisibility::Adaptive})),
+    useLegacyPinView(convertRawProp(context, rawProps, "useLegacyPinView", sourceProps.useLegacyPinView, {false})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsMarkerProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsMarker";
+}
+
+folly::dynamic RNMapsMarkerProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsMarkerProps();
+  const RNMapsMarkerProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsMarkerProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if (anchor != oldProps->anchor) {
+    result["anchor"] = toDynamic(anchor);
+  }
+    
+  if (calloutAnchor != oldProps->calloutAnchor) {
+    result["calloutAnchor"] = toDynamic(calloutAnchor);
+  }
+    
+  if (image != oldProps->image) {
+    result["image"] = toDynamic(image);
+  }
+    
+  if (calloutOffset != oldProps->calloutOffset) {
+    result["calloutOffset"] = toDynamic(calloutOffset);
+  }
+    
+  if (displayPriority != oldProps->displayPriority) {
+    result["displayPriority"] = toDynamic(displayPriority);
+  }
+    
+  if (centerOffset != oldProps->centerOffset) {
+    result["centerOffset"] = toDynamic(centerOffset);
+  }
+    
+  if (coordinate != oldProps->coordinate) {
+    result["coordinate"] = toDynamic(coordinate);
+  }
+    
+  if (description != oldProps->description) {
+    result["description"] = description;
+  }
+    
+  if (draggable != oldProps->draggable) {
+    result["draggable"] = draggable;
+  }
+    
+  if (title != oldProps->title) {
+    result["title"] = title;
+  }
+    
+  if (tracksViewChanges != oldProps->tracksViewChanges) {
+    result["tracksViewChanges"] = tracksViewChanges;
+  }
+    
+  if (identifier != oldProps->identifier) {
+    result["identifier"] = identifier;
+  }
+    
+  if (isPreselected != oldProps->isPreselected) {
+    result["isPreselected"] = isPreselected;
+  }
+    
+  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
+    result["opacity"] = opacity;
+  }
+    
+  if (pinColor != oldProps->pinColor) {
+    result["pinColor"] = *pinColor;
+  }
+    
+  if (titleVisibility != oldProps->titleVisibility) {
+    result["titleVisibility"] = toDynamic(titleVisibility);
+  }
+    
+  if (subtitleVisibility != oldProps->subtitleVisibility) {
+    result["subtitleVisibility"] = toDynamic(subtitleVisibility);
+  }
+    
+  if (useLegacyPinView != oldProps->useLegacyPinView) {
+    result["useLegacyPinView"] = useLegacyPinView;
+  }
+  return result;
+}
+#endif
+RNMapsOverlayProps::RNMapsOverlayProps(
+    const PropsParserContext &context,
+    const RNMapsOverlayProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    bearing(convertRawProp(context, rawProps, "bearing", sourceProps.bearing, {0.0})),
+    bounds(convertRawProp(context, rawProps, "bounds", sourceProps.bounds, {})),
+    image(convertRawProp(context, rawProps, "image", sourceProps.image, {})),
+    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
+    tappable(convertRawProp(context, rawProps, "tappable", sourceProps.tappable, {false})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsOverlayProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsOverlay";
+}
+
+folly::dynamic RNMapsOverlayProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsOverlayProps();
+  const RNMapsOverlayProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsOverlayProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if ((bearing != oldProps->bearing) && !(std::isnan(bearing) && std::isnan(oldProps->bearing))) {
+    result["bearing"] = bearing;
+  }
+    
+  if (bounds != oldProps->bounds) {
+    result["bounds"] = toDynamic(bounds);
+  }
+    
+  if (image != oldProps->image) {
+    result["image"] = toDynamic(image);
+  }
+    
+  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
+    result["opacity"] = opacity;
+  }
+    
+  if (tappable != oldProps->tappable) {
+    result["tappable"] = tappable;
+  }
+  return result;
+}
+#endif
+RNMapsPolylineProps::RNMapsPolylineProps(
+    const PropsParserContext &context,
+    const RNMapsPolylineProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    coordinates(convertRawProp(context, rawProps, "coordinates", sourceProps.coordinates, {})),
+    geodesic(convertRawProp(context, rawProps, "geodesic", sourceProps.geodesic, {false})),
+    lineCap(convertRawProp(context, rawProps, "lineCap", sourceProps.lineCap, {RNMapsPolylineLineCap::Butt})),
+    lineDashPattern(convertRawProp(context, rawProps, "lineDashPattern", sourceProps.lineDashPattern, {})),
+    lineJoin(convertRawProp(context, rawProps, "lineJoin", sourceProps.lineJoin, {RNMapsPolylineLineJoin::Miter})),
+    strokeColor(convertRawProp(context, rawProps, "strokeColor", sourceProps.strokeColor, {})),
+    strokeColors(convertRawProp(context, rawProps, "strokeColors", sourceProps.strokeColors, {})),
+    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {1.0})),
+    tappable(convertRawProp(context, rawProps, "tappable", sourceProps.tappable, {false})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsPolylineProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsPolyline";
+}
+
+folly::dynamic RNMapsPolylineProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsPolylineProps();
+  const RNMapsPolylineProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsPolylineProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if (coordinates != oldProps->coordinates) {
+    result["coordinates"] = toDynamic(coordinates);
+  }
+    
+  if (geodesic != oldProps->geodesic) {
+    result["geodesic"] = geodesic;
+  }
+    
+  if (lineCap != oldProps->lineCap) {
+    result["lineCap"] = toDynamic(lineCap);
+  }
+    
+  if (lineDashPattern != oldProps->lineDashPattern) {
+    result["lineDashPattern"] = toDynamic(lineDashPattern);
+  }
+    
+  if (lineJoin != oldProps->lineJoin) {
+    result["lineJoin"] = toDynamic(lineJoin);
+  }
+    
+  if (strokeColor != oldProps->strokeColor) {
+    result["strokeColor"] = *strokeColor;
+  }
+    
+  if (strokeColors != oldProps->strokeColors) {
+    result["strokeColors"] = toDynamic(strokeColors);
+  }
+    
+  if ((strokeWidth != oldProps->strokeWidth) && !(std::isnan(strokeWidth) && std::isnan(oldProps->strokeWidth))) {
+    result["strokeWidth"] = strokeWidth;
+  }
+    
+  if (tappable != oldProps->tappable) {
+    result["tappable"] = tappable;
+  }
+  return result;
+}
+#endif
+RNMapsUrlTileProps::RNMapsUrlTileProps(
+    const PropsParserContext &context,
+    const RNMapsUrlTileProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    doubleTileSize(convertRawProp(context, rawProps, "doubleTileSize", sourceProps.doubleTileSize, {false})),
+    flipY(convertRawProp(context, rawProps, "flipY", sourceProps.flipY, {false})),
+    maximumNativeZ(convertRawProp(context, rawProps, "maximumNativeZ", sourceProps.maximumNativeZ, {100})),
+    maximumZ(convertRawProp(context, rawProps, "maximumZ", sourceProps.maximumZ, {100})),
+    minimumZ(convertRawProp(context, rawProps, "minimumZ", sourceProps.minimumZ, {0})),
+    offlineMode(convertRawProp(context, rawProps, "offlineMode", sourceProps.offlineMode, {false})),
+    shouldReplaceMapContent(convertRawProp(context, rawProps, "shouldReplaceMapContent", sourceProps.shouldReplaceMapContent, {false})),
+    tileCacheMaxAge(convertRawProp(context, rawProps, "tileCacheMaxAge", sourceProps.tileCacheMaxAge, {0})),
+    tileCachePath(convertRawProp(context, rawProps, "tileCachePath", sourceProps.tileCachePath, {})),
+    tileSize(convertRawProp(context, rawProps, "tileSize", sourceProps.tileSize, {256})),
+    urlTemplate(convertRawProp(context, rawProps, "urlTemplate", sourceProps.urlTemplate, {})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsUrlTileProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsUrlTile";
+}
+
+folly::dynamic RNMapsUrlTileProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsUrlTileProps();
+  const RNMapsUrlTileProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsUrlTileProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if (doubleTileSize != oldProps->doubleTileSize) {
+    result["doubleTileSize"] = doubleTileSize;
+  }
+    
+  if (flipY != oldProps->flipY) {
+    result["flipY"] = flipY;
+  }
+    
+  if (maximumNativeZ != oldProps->maximumNativeZ) {
+    result["maximumNativeZ"] = maximumNativeZ;
+  }
+    
+  if (maximumZ != oldProps->maximumZ) {
+    result["maximumZ"] = maximumZ;
+  }
+    
+  if (minimumZ != oldProps->minimumZ) {
+    result["minimumZ"] = minimumZ;
+  }
+    
+  if (offlineMode != oldProps->offlineMode) {
+    result["offlineMode"] = offlineMode;
+  }
+    
+  if (shouldReplaceMapContent != oldProps->shouldReplaceMapContent) {
+    result["shouldReplaceMapContent"] = shouldReplaceMapContent;
+  }
+    
+  if (tileCacheMaxAge != oldProps->tileCacheMaxAge) {
+    result["tileCacheMaxAge"] = tileCacheMaxAge;
+  }
+    
+  if (tileCachePath != oldProps->tileCachePath) {
+    result["tileCachePath"] = tileCachePath;
+  }
+    
+  if (tileSize != oldProps->tileSize) {
+    result["tileSize"] = tileSize;
+  }
+    
+  if (urlTemplate != oldProps->urlTemplate) {
+    result["urlTemplate"] = urlTemplate;
+  }
+  return result;
+}
+#endif
+RNMapsWMSTileProps::RNMapsWMSTileProps(
+    const PropsParserContext &context,
+    const RNMapsWMSTileProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    maximumNativeZ(convertRawProp(context, rawProps, "maximumNativeZ", sourceProps.maximumNativeZ, {100})),
+    maximumZ(convertRawProp(context, rawProps, "maximumZ", sourceProps.maximumZ, {100})),
+    minimumZ(convertRawProp(context, rawProps, "minimumZ", sourceProps.minimumZ, {0})),
+    offlineMode(convertRawProp(context, rawProps, "offlineMode", sourceProps.offlineMode, {false})),
+    shouldReplaceMapContent(convertRawProp(context, rawProps, "shouldReplaceMapContent", sourceProps.shouldReplaceMapContent, {false})),
+    tileCacheMaxAge(convertRawProp(context, rawProps, "tileCacheMaxAge", sourceProps.tileCacheMaxAge, {0})),
+    tileCachePath(convertRawProp(context, rawProps, "tileCachePath", sourceProps.tileCachePath, {})),
+    tileSize(convertRawProp(context, rawProps, "tileSize", sourceProps.tileSize, {256})),
+    urlTemplate(convertRawProp(context, rawProps, "urlTemplate", sourceProps.urlTemplate, {})) {}
+    
+#ifdef RN_SERIALIZABLE_STATE
+ComponentName RNMapsWMSTileProps::getDiffPropsImplementationTarget() const {
+  return "RNMapsWMSTile";
+}
+
+folly::dynamic RNMapsWMSTileProps::getDiffProps(
+    const Props* prevProps) const {
+  static const auto defaultProps = RNMapsWMSTileProps();
+  const RNMapsWMSTileProps* oldProps = prevProps == nullptr
+      ? &defaultProps
+      : static_cast<const RNMapsWMSTileProps*>(prevProps);
+  if (this == oldProps) {
+    return folly::dynamic::object();
+  }
+  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
+  
+  if (maximumNativeZ != oldProps->maximumNativeZ) {
+    result["maximumNativeZ"] = maximumNativeZ;
+  }
+    
+  if (maximumZ != oldProps->maximumZ) {
+    result["maximumZ"] = maximumZ;
+  }
+    
+  if (minimumZ != oldProps->minimumZ) {
+    result["minimumZ"] = minimumZ;
+  }
+    
+  if (offlineMode != oldProps->offlineMode) {
+    result["offlineMode"] = offlineMode;
+  }
+    
+  if (shouldReplaceMapContent != oldProps->shouldReplaceMapContent) {
+    result["shouldReplaceMapContent"] = shouldReplaceMapContent;
+  }
+    
+  if (tileCacheMaxAge != oldProps->tileCacheMaxAge) {
+    result["tileCacheMaxAge"] = tileCacheMaxAge;
+  }
+    
+  if (tileCachePath != oldProps->tileCachePath) {
+    result["tileCachePath"] = tileCachePath;
+  }
+    
+  if (tileSize != oldProps->tileSize) {
+    result["tileSize"] = tileSize;
+  }
+    
+  if (urlTemplate != oldProps->urlTemplate) {
+    result["urlTemplate"] = urlTemplate;
+  }
+  return result;
+}
+#endif
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/Props.h b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/Props.h
new file mode 100644
index 0000000..f7b7757
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/Props.h
@@ -0,0 +1,1987 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsH.js
+ */
+#pragma once
+
+#include <react/renderer/components/view/ViewProps.h>
+#include <react/renderer/core/PropsParserContext.h>
+#include <react/renderer/core/propsConversions.h>
+#include <react/renderer/graphics/Color.h>
+#include <react/renderer/imagemanager/primitives.h>
+#include <vector>
+
+namespace facebook::react {
+
+class RNMapsCalloutProps final : public ViewProps {
+ public:
+  RNMapsCalloutProps() = default;
+  RNMapsCalloutProps(const PropsParserContext& context, const RNMapsCalloutProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  bool alphaHitTest{false};
+  bool tooltip{false};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+struct RNMapsCircleCenterStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsCircleCenterStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsCircleCenterStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsCircleCenterStruct &value) {
+  return "[Object RNMapsCircleCenterStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsCircleCenterStruct &value) {
+  return value.toDynamic();
+}
+#endif
+class RNMapsCircleProps final : public ViewProps {
+ public:
+  RNMapsCircleProps() = default;
+  RNMapsCircleProps(const PropsParserContext& context, const RNMapsCircleProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  RNMapsCircleCenterStruct center{};
+  SharedColor fillColor{};
+  double radius{0.0};
+  SharedColor strokeColor{};
+  Float strokeWidth{1.0};
+  bool tappable{false};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+enum class RNMapsGoogleMapViewMapType { Hybrid, MutedStandard, None, Satellite, Standard, Terrain, SatelliteFlyover, HybridFlyover };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewMapType &result) {
+  auto string = (std::string)value;
+  if (string == "hybrid") { result = RNMapsGoogleMapViewMapType::Hybrid; return; }
+  if (string == "mutedStandard") { result = RNMapsGoogleMapViewMapType::MutedStandard; return; }
+  if (string == "none") { result = RNMapsGoogleMapViewMapType::None; return; }
+  if (string == "satellite") { result = RNMapsGoogleMapViewMapType::Satellite; return; }
+  if (string == "standard") { result = RNMapsGoogleMapViewMapType::Standard; return; }
+  if (string == "terrain") { result = RNMapsGoogleMapViewMapType::Terrain; return; }
+  if (string == "satelliteFlyover") { result = RNMapsGoogleMapViewMapType::SatelliteFlyover; return; }
+  if (string == "hybridFlyover") { result = RNMapsGoogleMapViewMapType::HybridFlyover; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewMapType &value) {
+  switch (value) {
+    case RNMapsGoogleMapViewMapType::Hybrid: return "hybrid";
+    case RNMapsGoogleMapViewMapType::MutedStandard: return "mutedStandard";
+    case RNMapsGoogleMapViewMapType::None: return "none";
+    case RNMapsGoogleMapViewMapType::Satellite: return "satellite";
+    case RNMapsGoogleMapViewMapType::Standard: return "standard";
+    case RNMapsGoogleMapViewMapType::Terrain: return "terrain";
+    case RNMapsGoogleMapViewMapType::SatelliteFlyover: return "satelliteFlyover";
+    case RNMapsGoogleMapViewMapType::HybridFlyover: return "hybridFlyover";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewMapType &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsGoogleMapViewPaddingAdjustmentBehavior { Always, Automatic, Never };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewPaddingAdjustmentBehavior &result) {
+  auto string = (std::string)value;
+  if (string == "always") { result = RNMapsGoogleMapViewPaddingAdjustmentBehavior::Always; return; }
+  if (string == "automatic") { result = RNMapsGoogleMapViewPaddingAdjustmentBehavior::Automatic; return; }
+  if (string == "never") { result = RNMapsGoogleMapViewPaddingAdjustmentBehavior::Never; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewPaddingAdjustmentBehavior &value) {
+  switch (value) {
+    case RNMapsGoogleMapViewPaddingAdjustmentBehavior::Always: return "always";
+    case RNMapsGoogleMapViewPaddingAdjustmentBehavior::Automatic: return "automatic";
+    case RNMapsGoogleMapViewPaddingAdjustmentBehavior::Never: return "never";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewPaddingAdjustmentBehavior &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsGoogleMapViewUserInterfaceStyle { System, Light, Dark };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewUserInterfaceStyle &result) {
+  auto string = (std::string)value;
+  if (string == "system") { result = RNMapsGoogleMapViewUserInterfaceStyle::System; return; }
+  if (string == "light") { result = RNMapsGoogleMapViewUserInterfaceStyle::Light; return; }
+  if (string == "dark") { result = RNMapsGoogleMapViewUserInterfaceStyle::Dark; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewUserInterfaceStyle &value) {
+  switch (value) {
+    case RNMapsGoogleMapViewUserInterfaceStyle::System: return "system";
+    case RNMapsGoogleMapViewUserInterfaceStyle::Light: return "light";
+    case RNMapsGoogleMapViewUserInterfaceStyle::Dark: return "dark";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewUserInterfaceStyle &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsGoogleMapViewUserLocationPriority { Balanced, High, Low, Passive };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewUserLocationPriority &result) {
+  auto string = (std::string)value;
+  if (string == "balanced") { result = RNMapsGoogleMapViewUserLocationPriority::Balanced; return; }
+  if (string == "high") { result = RNMapsGoogleMapViewUserLocationPriority::High; return; }
+  if (string == "low") { result = RNMapsGoogleMapViewUserLocationPriority::Low; return; }
+  if (string == "passive") { result = RNMapsGoogleMapViewUserLocationPriority::Passive; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewUserLocationPriority &value) {
+  switch (value) {
+    case RNMapsGoogleMapViewUserLocationPriority::Balanced: return "balanced";
+    case RNMapsGoogleMapViewUserLocationPriority::High: return "high";
+    case RNMapsGoogleMapViewUserLocationPriority::Low: return "low";
+    case RNMapsGoogleMapViewUserLocationPriority::Passive: return "passive";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewUserLocationPriority &value) {
+  return toString(value);
+}
+#endif
+struct RNMapsGoogleMapViewCameraCenterStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsGoogleMapViewCameraCenterStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewCameraCenterStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewCameraCenterStruct &value) {
+  return "[Object RNMapsGoogleMapViewCameraCenterStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewCameraCenterStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsGoogleMapViewCameraStruct {
+  double altitude{0.0};
+  RNMapsGoogleMapViewCameraCenterStruct center{};
+  double heading{0.0};
+  double pitch{0.0};
+  Float zoom{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsGoogleMapViewCameraStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["altitude"] = altitude;
+    result["center"] = ::facebook::react::toDynamic(center);
+    result["heading"] = heading;
+    result["pitch"] = pitch;
+    result["zoom"] = zoom;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewCameraStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_altitude = map.find("altitude");
+  if (tmp_altitude != map.end()) {
+    fromRawValue(context, tmp_altitude->second, result.altitude);
+  }
+  auto tmp_center = map.find("center");
+  if (tmp_center != map.end()) {
+    fromRawValue(context, tmp_center->second, result.center);
+  }
+  auto tmp_heading = map.find("heading");
+  if (tmp_heading != map.end()) {
+    fromRawValue(context, tmp_heading->second, result.heading);
+  }
+  auto tmp_pitch = map.find("pitch");
+  if (tmp_pitch != map.end()) {
+    fromRawValue(context, tmp_pitch->second, result.pitch);
+  }
+  auto tmp_zoom = map.find("zoom");
+  if (tmp_zoom != map.end()) {
+    fromRawValue(context, tmp_zoom->second, result.zoom);
+  }
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewCameraStruct &value) {
+  return "[Object RNMapsGoogleMapViewCameraStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewCameraStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsGoogleMapViewInitialCameraCenterStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsGoogleMapViewInitialCameraCenterStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewInitialCameraCenterStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewInitialCameraCenterStruct &value) {
+  return "[Object RNMapsGoogleMapViewInitialCameraCenterStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewInitialCameraCenterStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsGoogleMapViewInitialCameraStruct {
+  double altitude{0.0};
+  RNMapsGoogleMapViewInitialCameraCenterStruct center{};
+  double heading{0.0};
+  double pitch{0.0};
+  Float zoom{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsGoogleMapViewInitialCameraStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["altitude"] = altitude;
+    result["center"] = ::facebook::react::toDynamic(center);
+    result["heading"] = heading;
+    result["pitch"] = pitch;
+    result["zoom"] = zoom;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewInitialCameraStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_altitude = map.find("altitude");
+  if (tmp_altitude != map.end()) {
+    fromRawValue(context, tmp_altitude->second, result.altitude);
+  }
+  auto tmp_center = map.find("center");
+  if (tmp_center != map.end()) {
+    fromRawValue(context, tmp_center->second, result.center);
+  }
+  auto tmp_heading = map.find("heading");
+  if (tmp_heading != map.end()) {
+    fromRawValue(context, tmp_heading->second, result.heading);
+  }
+  auto tmp_pitch = map.find("pitch");
+  if (tmp_pitch != map.end()) {
+    fromRawValue(context, tmp_pitch->second, result.pitch);
+  }
+  auto tmp_zoom = map.find("zoom");
+  if (tmp_zoom != map.end()) {
+    fromRawValue(context, tmp_zoom->second, result.zoom);
+  }
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewInitialCameraStruct &value) {
+  return "[Object RNMapsGoogleMapViewInitialCameraStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewInitialCameraStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsGoogleMapViewInitialRegionStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+  double latitudeDelta{0.0};
+  double longitudeDelta{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsGoogleMapViewInitialRegionStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    result["latitudeDelta"] = latitudeDelta;
+    result["longitudeDelta"] = longitudeDelta;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewInitialRegionStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+  auto tmp_latitudeDelta = map.find("latitudeDelta");
+  if (tmp_latitudeDelta != map.end()) {
+    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
+  }
+  auto tmp_longitudeDelta = map.find("longitudeDelta");
+  if (tmp_longitudeDelta != map.end()) {
+    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
+  }
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewInitialRegionStruct &value) {
+  return "[Object RNMapsGoogleMapViewInitialRegionStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewInitialRegionStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsGoogleMapViewMapPaddingStruct {
+  double top{0.0};
+  double right{0.0};
+  double bottom{0.0};
+  double left{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsGoogleMapViewMapPaddingStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["top"] = top;
+    result["right"] = right;
+    result["bottom"] = bottom;
+    result["left"] = left;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewMapPaddingStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_top = map.find("top");
+  if (tmp_top != map.end()) {
+    fromRawValue(context, tmp_top->second, result.top);
+  }
+  auto tmp_right = map.find("right");
+  if (tmp_right != map.end()) {
+    fromRawValue(context, tmp_right->second, result.right);
+  }
+  auto tmp_bottom = map.find("bottom");
+  if (tmp_bottom != map.end()) {
+    fromRawValue(context, tmp_bottom->second, result.bottom);
+  }
+  auto tmp_left = map.find("left");
+  if (tmp_left != map.end()) {
+    fromRawValue(context, tmp_left->second, result.left);
+  }
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewMapPaddingStruct &value) {
+  return "[Object RNMapsGoogleMapViewMapPaddingStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewMapPaddingStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsGoogleMapViewRegionStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+  double latitudeDelta{0.0};
+  double longitudeDelta{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsGoogleMapViewRegionStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    result["latitudeDelta"] = latitudeDelta;
+    result["longitudeDelta"] = longitudeDelta;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGoogleMapViewRegionStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+  auto tmp_latitudeDelta = map.find("latitudeDelta");
+  if (tmp_latitudeDelta != map.end()) {
+    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
+  }
+  auto tmp_longitudeDelta = map.find("longitudeDelta");
+  if (tmp_longitudeDelta != map.end()) {
+    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
+  }
+}
+
+static inline std::string toString(const RNMapsGoogleMapViewRegionStruct &value) {
+  return "[Object RNMapsGoogleMapViewRegionStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGoogleMapViewRegionStruct &value) {
+  return value.toDynamic();
+}
+#endif
+class RNMapsGoogleMapViewProps final : public ViewProps {
+ public:
+  RNMapsGoogleMapViewProps() = default;
+  RNMapsGoogleMapViewProps(const PropsParserContext& context, const RNMapsGoogleMapViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  RNMapsGoogleMapViewCameraStruct camera{};
+  RNMapsGoogleMapViewInitialCameraStruct initialCamera{};
+  RNMapsGoogleMapViewInitialRegionStruct initialRegion{};
+  std::string kmlSrc{};
+  std::string googleMapId{};
+  SharedColor loadingBackgroundColor{};
+  RNMapsGoogleMapViewMapPaddingStruct mapPadding{};
+  RNMapsGoogleMapViewMapType mapType{RNMapsGoogleMapViewMapType::Standard};
+  Float maxZoom{0.0};
+  Float minZoom{0.0};
+  RNMapsGoogleMapViewPaddingAdjustmentBehavior paddingAdjustmentBehavior{RNMapsGoogleMapViewPaddingAdjustmentBehavior::Never};
+  bool pitchEnabled{true};
+  RNMapsGoogleMapViewRegionStruct region{};
+  bool rotateEnabled{true};
+  bool scrollDuringRotateOrZoomEnabled{true};
+  bool scrollEnabled{true};
+  bool showsBuildings{true};
+  bool showsCompass{false};
+  bool showsIndoorLevelPicker{false};
+  bool showsIndoors{true};
+  bool showsMyLocationButton{false};
+  bool showsScale{false};
+  bool showsTraffic{false};
+  bool showsUserLocation{false};
+  RNMapsGoogleMapViewUserInterfaceStyle userInterfaceStyle{RNMapsGoogleMapViewUserInterfaceStyle::System};
+  std::string customMapStyleString{};
+  bool userLocationCalloutEnabled{false};
+  int userLocationFastestInterval{0};
+  RNMapsGoogleMapViewUserLocationPriority userLocationPriority{RNMapsGoogleMapViewUserLocationPriority::High};
+  int userLocationUpdateInterval{0};
+  bool zoomControlEnabled{false};
+  bool zoomEnabled{true};
+  bool zoomTapEnabled{true};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+struct RNMapsGooglePolygonCoordinatesStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsGooglePolygonCoordinatesStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGooglePolygonCoordinatesStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsGooglePolygonCoordinatesStruct &value) {
+  return "[Object RNMapsGooglePolygonCoordinatesStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGooglePolygonCoordinatesStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNMapsGooglePolygonCoordinatesStruct> &result) {
+  auto items = (std::vector<RawValue>)value;
+  for (const auto &item : items) {
+    RNMapsGooglePolygonCoordinatesStruct newItem;
+    fromRawValue(context, item, newItem);
+    result.emplace_back(newItem);
+  }
+}
+
+
+struct RNMapsGooglePolygonHolesStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsGooglePolygonHolesStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsGooglePolygonHolesStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsGooglePolygonHolesStruct &value) {
+  return "[Object RNMapsGooglePolygonHolesStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsGooglePolygonHolesStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<std::vector<RNMapsGooglePolygonHolesStruct>> &result) {
+  auto items = (std::vector<std::vector<RawValue>>)value;
+  for (const std::vector<RawValue> &item : items) {
+    auto nestedArray = std::vector<RNMapsGooglePolygonHolesStruct>{};
+    for (const RawValue &nestedItem : item) {
+      RNMapsGooglePolygonHolesStruct newItem;
+      fromRawValue(context, nestedItem, newItem);
+      nestedArray.emplace_back(newItem);
+    }
+    result.emplace_back(nestedArray);
+  }
+}
+
+class RNMapsGooglePolygonProps final : public ViewProps {
+ public:
+  RNMapsGooglePolygonProps() = default;
+  RNMapsGooglePolygonProps(const PropsParserContext& context, const RNMapsGooglePolygonProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  std::vector<RNMapsGooglePolygonCoordinatesStruct> coordinates{};
+  SharedColor fillColor{};
+  SharedColor strokeColor{};
+  Float strokeWidth{1.0};
+  bool geodesic{false};
+  std::vector<std::vector<RNMapsGooglePolygonHolesStruct>> holes{};
+  bool tappable{false};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+enum class RNMapsMapViewGoogleRenderer { LATEST, LEGACY };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewGoogleRenderer &result) {
+  auto string = (std::string)value;
+  if (string == "LATEST") { result = RNMapsMapViewGoogleRenderer::LATEST; return; }
+  if (string == "LEGACY") { result = RNMapsMapViewGoogleRenderer::LEGACY; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsMapViewGoogleRenderer &value) {
+  switch (value) {
+    case RNMapsMapViewGoogleRenderer::LATEST: return "LATEST";
+    case RNMapsMapViewGoogleRenderer::LEGACY: return "LEGACY";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewGoogleRenderer &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsMapViewMapType { Hybrid, MutedStandard, None, Satellite, Standard, Terrain, SatelliteFlyover, HybridFlyover };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewMapType &result) {
+  auto string = (std::string)value;
+  if (string == "hybrid") { result = RNMapsMapViewMapType::Hybrid; return; }
+  if (string == "mutedStandard") { result = RNMapsMapViewMapType::MutedStandard; return; }
+  if (string == "none") { result = RNMapsMapViewMapType::None; return; }
+  if (string == "satellite") { result = RNMapsMapViewMapType::Satellite; return; }
+  if (string == "standard") { result = RNMapsMapViewMapType::Standard; return; }
+  if (string == "terrain") { result = RNMapsMapViewMapType::Terrain; return; }
+  if (string == "satelliteFlyover") { result = RNMapsMapViewMapType::SatelliteFlyover; return; }
+  if (string == "hybridFlyover") { result = RNMapsMapViewMapType::HybridFlyover; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsMapViewMapType &value) {
+  switch (value) {
+    case RNMapsMapViewMapType::Hybrid: return "hybrid";
+    case RNMapsMapViewMapType::MutedStandard: return "mutedStandard";
+    case RNMapsMapViewMapType::None: return "none";
+    case RNMapsMapViewMapType::Satellite: return "satellite";
+    case RNMapsMapViewMapType::Standard: return "standard";
+    case RNMapsMapViewMapType::Terrain: return "terrain";
+    case RNMapsMapViewMapType::SatelliteFlyover: return "satelliteFlyover";
+    case RNMapsMapViewMapType::HybridFlyover: return "hybridFlyover";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewMapType &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsMapViewPaddingAdjustmentBehavior { Always, Automatic, Never };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewPaddingAdjustmentBehavior &result) {
+  auto string = (std::string)value;
+  if (string == "always") { result = RNMapsMapViewPaddingAdjustmentBehavior::Always; return; }
+  if (string == "automatic") { result = RNMapsMapViewPaddingAdjustmentBehavior::Automatic; return; }
+  if (string == "never") { result = RNMapsMapViewPaddingAdjustmentBehavior::Never; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsMapViewPaddingAdjustmentBehavior &value) {
+  switch (value) {
+    case RNMapsMapViewPaddingAdjustmentBehavior::Always: return "always";
+    case RNMapsMapViewPaddingAdjustmentBehavior::Automatic: return "automatic";
+    case RNMapsMapViewPaddingAdjustmentBehavior::Never: return "never";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewPaddingAdjustmentBehavior &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsMapViewUserInterfaceStyle { System, Light, Dark };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewUserInterfaceStyle &result) {
+  auto string = (std::string)value;
+  if (string == "system") { result = RNMapsMapViewUserInterfaceStyle::System; return; }
+  if (string == "light") { result = RNMapsMapViewUserInterfaceStyle::Light; return; }
+  if (string == "dark") { result = RNMapsMapViewUserInterfaceStyle::Dark; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsMapViewUserInterfaceStyle &value) {
+  switch (value) {
+    case RNMapsMapViewUserInterfaceStyle::System: return "system";
+    case RNMapsMapViewUserInterfaceStyle::Light: return "light";
+    case RNMapsMapViewUserInterfaceStyle::Dark: return "dark";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewUserInterfaceStyle &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsMapViewUserLocationPriority { Balanced, High, Low, Passive };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewUserLocationPriority &result) {
+  auto string = (std::string)value;
+  if (string == "balanced") { result = RNMapsMapViewUserLocationPriority::Balanced; return; }
+  if (string == "high") { result = RNMapsMapViewUserLocationPriority::High; return; }
+  if (string == "low") { result = RNMapsMapViewUserLocationPriority::Low; return; }
+  if (string == "passive") { result = RNMapsMapViewUserLocationPriority::Passive; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsMapViewUserLocationPriority &value) {
+  switch (value) {
+    case RNMapsMapViewUserLocationPriority::Balanced: return "balanced";
+    case RNMapsMapViewUserLocationPriority::High: return "high";
+    case RNMapsMapViewUserLocationPriority::Low: return "low";
+    case RNMapsMapViewUserLocationPriority::Passive: return "passive";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewUserLocationPriority &value) {
+  return toString(value);
+}
+#endif
+struct RNMapsMapViewCameraCenterStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewCameraCenterStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewCameraCenterStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewCameraCenterStruct &value) {
+  return "[Object RNMapsMapViewCameraCenterStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewCameraCenterStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMapViewCameraStruct {
+  double altitude{0.0};
+  RNMapsMapViewCameraCenterStruct center{};
+  double heading{0.0};
+  double pitch{0.0};
+  Float zoom{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewCameraStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["altitude"] = altitude;
+    result["center"] = ::facebook::react::toDynamic(center);
+    result["heading"] = heading;
+    result["pitch"] = pitch;
+    result["zoom"] = zoom;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewCameraStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_altitude = map.find("altitude");
+  if (tmp_altitude != map.end()) {
+    fromRawValue(context, tmp_altitude->second, result.altitude);
+  }
+  auto tmp_center = map.find("center");
+  if (tmp_center != map.end()) {
+    fromRawValue(context, tmp_center->second, result.center);
+  }
+  auto tmp_heading = map.find("heading");
+  if (tmp_heading != map.end()) {
+    fromRawValue(context, tmp_heading->second, result.heading);
+  }
+  auto tmp_pitch = map.find("pitch");
+  if (tmp_pitch != map.end()) {
+    fromRawValue(context, tmp_pitch->second, result.pitch);
+  }
+  auto tmp_zoom = map.find("zoom");
+  if (tmp_zoom != map.end()) {
+    fromRawValue(context, tmp_zoom->second, result.zoom);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewCameraStruct &value) {
+  return "[Object RNMapsMapViewCameraStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewCameraStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMapViewCompassOffsetStruct {
+  double x{0.0};
+  double y{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewCompassOffsetStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["x"] = x;
+    result["y"] = y;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewCompassOffsetStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_x = map.find("x");
+  if (tmp_x != map.end()) {
+    fromRawValue(context, tmp_x->second, result.x);
+  }
+  auto tmp_y = map.find("y");
+  if (tmp_y != map.end()) {
+    fromRawValue(context, tmp_y->second, result.y);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewCompassOffsetStruct &value) {
+  return "[Object RNMapsMapViewCompassOffsetStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewCompassOffsetStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMapViewInitialCameraCenterStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewInitialCameraCenterStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewInitialCameraCenterStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewInitialCameraCenterStruct &value) {
+  return "[Object RNMapsMapViewInitialCameraCenterStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewInitialCameraCenterStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMapViewInitialCameraStruct {
+  double altitude{0.0};
+  RNMapsMapViewInitialCameraCenterStruct center{};
+  double heading{0.0};
+  double pitch{0.0};
+  Float zoom{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewInitialCameraStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["altitude"] = altitude;
+    result["center"] = ::facebook::react::toDynamic(center);
+    result["heading"] = heading;
+    result["pitch"] = pitch;
+    result["zoom"] = zoom;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewInitialCameraStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_altitude = map.find("altitude");
+  if (tmp_altitude != map.end()) {
+    fromRawValue(context, tmp_altitude->second, result.altitude);
+  }
+  auto tmp_center = map.find("center");
+  if (tmp_center != map.end()) {
+    fromRawValue(context, tmp_center->second, result.center);
+  }
+  auto tmp_heading = map.find("heading");
+  if (tmp_heading != map.end()) {
+    fromRawValue(context, tmp_heading->second, result.heading);
+  }
+  auto tmp_pitch = map.find("pitch");
+  if (tmp_pitch != map.end()) {
+    fromRawValue(context, tmp_pitch->second, result.pitch);
+  }
+  auto tmp_zoom = map.find("zoom");
+  if (tmp_zoom != map.end()) {
+    fromRawValue(context, tmp_zoom->second, result.zoom);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewInitialCameraStruct &value) {
+  return "[Object RNMapsMapViewInitialCameraStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewInitialCameraStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMapViewInitialRegionStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+  double latitudeDelta{0.0};
+  double longitudeDelta{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewInitialRegionStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    result["latitudeDelta"] = latitudeDelta;
+    result["longitudeDelta"] = longitudeDelta;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewInitialRegionStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+  auto tmp_latitudeDelta = map.find("latitudeDelta");
+  if (tmp_latitudeDelta != map.end()) {
+    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
+  }
+  auto tmp_longitudeDelta = map.find("longitudeDelta");
+  if (tmp_longitudeDelta != map.end()) {
+    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewInitialRegionStruct &value) {
+  return "[Object RNMapsMapViewInitialRegionStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewInitialRegionStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMapViewLegalLabelInsetsStruct {
+  double top{0.0};
+  double right{0.0};
+  double bottom{0.0};
+  double left{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewLegalLabelInsetsStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["top"] = top;
+    result["right"] = right;
+    result["bottom"] = bottom;
+    result["left"] = left;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewLegalLabelInsetsStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_top = map.find("top");
+  if (tmp_top != map.end()) {
+    fromRawValue(context, tmp_top->second, result.top);
+  }
+  auto tmp_right = map.find("right");
+  if (tmp_right != map.end()) {
+    fromRawValue(context, tmp_right->second, result.right);
+  }
+  auto tmp_bottom = map.find("bottom");
+  if (tmp_bottom != map.end()) {
+    fromRawValue(context, tmp_bottom->second, result.bottom);
+  }
+  auto tmp_left = map.find("left");
+  if (tmp_left != map.end()) {
+    fromRawValue(context, tmp_left->second, result.left);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewLegalLabelInsetsStruct &value) {
+  return "[Object RNMapsMapViewLegalLabelInsetsStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewLegalLabelInsetsStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMapViewMapPaddingStruct {
+  double top{0.0};
+  double right{0.0};
+  double bottom{0.0};
+  double left{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewMapPaddingStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["top"] = top;
+    result["right"] = right;
+    result["bottom"] = bottom;
+    result["left"] = left;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewMapPaddingStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_top = map.find("top");
+  if (tmp_top != map.end()) {
+    fromRawValue(context, tmp_top->second, result.top);
+  }
+  auto tmp_right = map.find("right");
+  if (tmp_right != map.end()) {
+    fromRawValue(context, tmp_right->second, result.right);
+  }
+  auto tmp_bottom = map.find("bottom");
+  if (tmp_bottom != map.end()) {
+    fromRawValue(context, tmp_bottom->second, result.bottom);
+  }
+  auto tmp_left = map.find("left");
+  if (tmp_left != map.end()) {
+    fromRawValue(context, tmp_left->second, result.left);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewMapPaddingStruct &value) {
+  return "[Object RNMapsMapViewMapPaddingStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewMapPaddingStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMapViewRegionStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+  double latitudeDelta{0.0};
+  double longitudeDelta{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewRegionStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    result["latitudeDelta"] = latitudeDelta;
+    result["longitudeDelta"] = longitudeDelta;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewRegionStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+  auto tmp_latitudeDelta = map.find("latitudeDelta");
+  if (tmp_latitudeDelta != map.end()) {
+    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
+  }
+  auto tmp_longitudeDelta = map.find("longitudeDelta");
+  if (tmp_longitudeDelta != map.end()) {
+    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewRegionStruct &value) {
+  return "[Object RNMapsMapViewRegionStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewRegionStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMapViewCameraZoomRangeStruct {
+  double minCenterCoordinateDistance{0.0};
+  double maxCenterCoordinateDistance{0.0};
+  bool animated{false};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMapViewCameraZoomRangeStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["minCenterCoordinateDistance"] = minCenterCoordinateDistance;
+    result["maxCenterCoordinateDistance"] = maxCenterCoordinateDistance;
+    result["animated"] = animated;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMapViewCameraZoomRangeStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_minCenterCoordinateDistance = map.find("minCenterCoordinateDistance");
+  if (tmp_minCenterCoordinateDistance != map.end()) {
+    fromRawValue(context, tmp_minCenterCoordinateDistance->second, result.minCenterCoordinateDistance);
+  }
+  auto tmp_maxCenterCoordinateDistance = map.find("maxCenterCoordinateDistance");
+  if (tmp_maxCenterCoordinateDistance != map.end()) {
+    fromRawValue(context, tmp_maxCenterCoordinateDistance->second, result.maxCenterCoordinateDistance);
+  }
+  auto tmp_animated = map.find("animated");
+  if (tmp_animated != map.end()) {
+    fromRawValue(context, tmp_animated->second, result.animated);
+  }
+}
+
+static inline std::string toString(const RNMapsMapViewCameraZoomRangeStruct &value) {
+  return "[Object RNMapsMapViewCameraZoomRangeStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMapViewCameraZoomRangeStruct &value) {
+  return value.toDynamic();
+}
+#endif
+class RNMapsMapViewProps final : public ViewProps {
+ public:
+  RNMapsMapViewProps() = default;
+  RNMapsMapViewProps(const PropsParserContext& context, const RNMapsMapViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  bool cacheEnabled{false};
+  RNMapsMapViewCameraStruct camera{};
+  RNMapsMapViewCompassOffsetStruct compassOffset{};
+  bool followsUserLocation{false};
+  bool poiClickEnabled{false};
+  RNMapsMapViewInitialCameraStruct initialCamera{};
+  RNMapsMapViewInitialRegionStruct initialRegion{};
+  std::string kmlSrc{};
+  RNMapsMapViewLegalLabelInsetsStruct legalLabelInsets{};
+  bool liteMode{false};
+  std::string googleMapId{};
+  RNMapsMapViewGoogleRenderer googleRenderer{RNMapsMapViewGoogleRenderer::LATEST};
+  SharedColor loadingBackgroundColor{};
+  bool loadingEnabled{false};
+  SharedColor loadingIndicatorColor{};
+  RNMapsMapViewMapPaddingStruct mapPadding{};
+  RNMapsMapViewMapType mapType{RNMapsMapViewMapType::Standard};
+  double maxDelta{0.0};
+  Float maxZoom{0.0};
+  double minDelta{0.0};
+  Float minZoom{0.0};
+  bool moveOnMarkerPress{true};
+  bool handlePanDrag{false};
+  RNMapsMapViewPaddingAdjustmentBehavior paddingAdjustmentBehavior{RNMapsMapViewPaddingAdjustmentBehavior::Never};
+  bool pitchEnabled{true};
+  RNMapsMapViewRegionStruct region{};
+  bool rotateEnabled{true};
+  bool scrollDuringRotateOrZoomEnabled{true};
+  bool scrollEnabled{true};
+  bool showsBuildings{true};
+  bool showsCompass{true};
+  bool showsIndoorLevelPicker{false};
+  bool showsIndoors{true};
+  bool showsPointsOfInterests{true};
+  std::vector<std::string> pointsOfInterestFilter{};
+  bool showsMyLocationButton{false};
+  bool showsScale{false};
+  bool showsUserLocation{false};
+  SharedColor tintColor{};
+  bool toolbarEnabled{true};
+  RNMapsMapViewUserInterfaceStyle userInterfaceStyle{RNMapsMapViewUserInterfaceStyle::System};
+  std::string customMapStyleString{};
+  std::string userLocationAnnotationTitle{};
+  bool userLocationCalloutEnabled{false};
+  int userLocationFastestInterval{5000};
+  RNMapsMapViewUserLocationPriority userLocationPriority{RNMapsMapViewUserLocationPriority::High};
+  int userLocationUpdateInterval{5000};
+  bool zoomControlEnabled{true};
+  bool zoomEnabled{true};
+  bool showsTraffic{false};
+  bool zoomTapEnabled{true};
+  RNMapsMapViewCameraZoomRangeStruct cameraZoomRange{};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+enum class RNMapsMarkerDisplayPriority { Required, High, Low };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMarkerDisplayPriority &result) {
+  auto string = (std::string)value;
+  if (string == "required") { result = RNMapsMarkerDisplayPriority::Required; return; }
+  if (string == "high") { result = RNMapsMarkerDisplayPriority::High; return; }
+  if (string == "low") { result = RNMapsMarkerDisplayPriority::Low; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsMarkerDisplayPriority &value) {
+  switch (value) {
+    case RNMapsMarkerDisplayPriority::Required: return "required";
+    case RNMapsMarkerDisplayPriority::High: return "high";
+    case RNMapsMarkerDisplayPriority::Low: return "low";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMarkerDisplayPriority &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsMarkerTitleVisibility { Hidden, Adaptive, Visible };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMarkerTitleVisibility &result) {
+  auto string = (std::string)value;
+  if (string == "hidden") { result = RNMapsMarkerTitleVisibility::Hidden; return; }
+  if (string == "adaptive") { result = RNMapsMarkerTitleVisibility::Adaptive; return; }
+  if (string == "visible") { result = RNMapsMarkerTitleVisibility::Visible; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsMarkerTitleVisibility &value) {
+  switch (value) {
+    case RNMapsMarkerTitleVisibility::Hidden: return "hidden";
+    case RNMapsMarkerTitleVisibility::Adaptive: return "adaptive";
+    case RNMapsMarkerTitleVisibility::Visible: return "visible";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMarkerTitleVisibility &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsMarkerSubtitleVisibility { Hidden, Adaptive, Visible };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMarkerSubtitleVisibility &result) {
+  auto string = (std::string)value;
+  if (string == "hidden") { result = RNMapsMarkerSubtitleVisibility::Hidden; return; }
+  if (string == "adaptive") { result = RNMapsMarkerSubtitleVisibility::Adaptive; return; }
+  if (string == "visible") { result = RNMapsMarkerSubtitleVisibility::Visible; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsMarkerSubtitleVisibility &value) {
+  switch (value) {
+    case RNMapsMarkerSubtitleVisibility::Hidden: return "hidden";
+    case RNMapsMarkerSubtitleVisibility::Adaptive: return "adaptive";
+    case RNMapsMarkerSubtitleVisibility::Visible: return "visible";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMarkerSubtitleVisibility &value) {
+  return toString(value);
+}
+#endif
+struct RNMapsMarkerAnchorStruct {
+  double x{0.0};
+  double y{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMarkerAnchorStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["x"] = x;
+    result["y"] = y;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMarkerAnchorStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_x = map.find("x");
+  if (tmp_x != map.end()) {
+    fromRawValue(context, tmp_x->second, result.x);
+  }
+  auto tmp_y = map.find("y");
+  if (tmp_y != map.end()) {
+    fromRawValue(context, tmp_y->second, result.y);
+  }
+}
+
+static inline std::string toString(const RNMapsMarkerAnchorStruct &value) {
+  return "[Object RNMapsMarkerAnchorStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMarkerAnchorStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMarkerCalloutAnchorStruct {
+  double x{0.0};
+  double y{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMarkerCalloutAnchorStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["x"] = x;
+    result["y"] = y;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMarkerCalloutAnchorStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_x = map.find("x");
+  if (tmp_x != map.end()) {
+    fromRawValue(context, tmp_x->second, result.x);
+  }
+  auto tmp_y = map.find("y");
+  if (tmp_y != map.end()) {
+    fromRawValue(context, tmp_y->second, result.y);
+  }
+}
+
+static inline std::string toString(const RNMapsMarkerCalloutAnchorStruct &value) {
+  return "[Object RNMapsMarkerCalloutAnchorStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMarkerCalloutAnchorStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMarkerCalloutOffsetStruct {
+  double x{0.0};
+  double y{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMarkerCalloutOffsetStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["x"] = x;
+    result["y"] = y;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMarkerCalloutOffsetStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_x = map.find("x");
+  if (tmp_x != map.end()) {
+    fromRawValue(context, tmp_x->second, result.x);
+  }
+  auto tmp_y = map.find("y");
+  if (tmp_y != map.end()) {
+    fromRawValue(context, tmp_y->second, result.y);
+  }
+}
+
+static inline std::string toString(const RNMapsMarkerCalloutOffsetStruct &value) {
+  return "[Object RNMapsMarkerCalloutOffsetStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMarkerCalloutOffsetStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMarkerCenterOffsetStruct {
+  double x{0.0};
+  double y{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMarkerCenterOffsetStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["x"] = x;
+    result["y"] = y;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMarkerCenterOffsetStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_x = map.find("x");
+  if (tmp_x != map.end()) {
+    fromRawValue(context, tmp_x->second, result.x);
+  }
+  auto tmp_y = map.find("y");
+  if (tmp_y != map.end()) {
+    fromRawValue(context, tmp_y->second, result.y);
+  }
+}
+
+static inline std::string toString(const RNMapsMarkerCenterOffsetStruct &value) {
+  return "[Object RNMapsMarkerCenterOffsetStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMarkerCenterOffsetStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsMarkerCoordinateStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsMarkerCoordinateStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsMarkerCoordinateStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsMarkerCoordinateStruct &value) {
+  return "[Object RNMapsMarkerCoordinateStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsMarkerCoordinateStruct &value) {
+  return value.toDynamic();
+}
+#endif
+class RNMapsMarkerProps final : public ViewProps {
+ public:
+  RNMapsMarkerProps() = default;
+  RNMapsMarkerProps(const PropsParserContext& context, const RNMapsMarkerProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  RNMapsMarkerAnchorStruct anchor{};
+  RNMapsMarkerCalloutAnchorStruct calloutAnchor{};
+  ImageSource image{};
+  RNMapsMarkerCalloutOffsetStruct calloutOffset{};
+  RNMapsMarkerDisplayPriority displayPriority{RNMapsMarkerDisplayPriority::Required};
+  RNMapsMarkerCenterOffsetStruct centerOffset{};
+  RNMapsMarkerCoordinateStruct coordinate{};
+  std::string description{};
+  bool draggable{false};
+  std::string title{};
+  bool tracksViewChanges{true};
+  std::string identifier{};
+  bool isPreselected{false};
+  double opacity{1.0};
+  SharedColor pinColor{};
+  RNMapsMarkerTitleVisibility titleVisibility{RNMapsMarkerTitleVisibility::Visible};
+  RNMapsMarkerSubtitleVisibility subtitleVisibility{RNMapsMarkerSubtitleVisibility::Adaptive};
+  bool useLegacyPinView{false};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+struct RNMapsOverlayBoundsNorthEastStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsOverlayBoundsNorthEastStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsOverlayBoundsNorthEastStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsOverlayBoundsNorthEastStruct &value) {
+  return "[Object RNMapsOverlayBoundsNorthEastStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsOverlayBoundsNorthEastStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsOverlayBoundsSouthWestStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsOverlayBoundsSouthWestStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsOverlayBoundsSouthWestStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsOverlayBoundsSouthWestStruct &value) {
+  return "[Object RNMapsOverlayBoundsSouthWestStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsOverlayBoundsSouthWestStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+struct RNMapsOverlayBoundsStruct {
+  RNMapsOverlayBoundsNorthEastStruct northEast{};
+  RNMapsOverlayBoundsSouthWestStruct southWest{};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsOverlayBoundsStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["northEast"] = ::facebook::react::toDynamic(northEast);
+    result["southWest"] = ::facebook::react::toDynamic(southWest);
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsOverlayBoundsStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_northEast = map.find("northEast");
+  if (tmp_northEast != map.end()) {
+    fromRawValue(context, tmp_northEast->second, result.northEast);
+  }
+  auto tmp_southWest = map.find("southWest");
+  if (tmp_southWest != map.end()) {
+    fromRawValue(context, tmp_southWest->second, result.southWest);
+  }
+}
+
+static inline std::string toString(const RNMapsOverlayBoundsStruct &value) {
+  return "[Object RNMapsOverlayBoundsStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsOverlayBoundsStruct &value) {
+  return value.toDynamic();
+}
+#endif
+class RNMapsOverlayProps final : public ViewProps {
+ public:
+  RNMapsOverlayProps() = default;
+  RNMapsOverlayProps(const PropsParserContext& context, const RNMapsOverlayProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  Float bearing{0.0};
+  RNMapsOverlayBoundsStruct bounds{};
+  ImageSource image{};
+  Float opacity{1.0};
+  bool tappable{false};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+enum class RNMapsPolylineLineCap { Butt, Round, Square };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsPolylineLineCap &result) {
+  auto string = (std::string)value;
+  if (string == "butt") { result = RNMapsPolylineLineCap::Butt; return; }
+  if (string == "round") { result = RNMapsPolylineLineCap::Round; return; }
+  if (string == "square") { result = RNMapsPolylineLineCap::Square; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsPolylineLineCap &value) {
+  switch (value) {
+    case RNMapsPolylineLineCap::Butt: return "butt";
+    case RNMapsPolylineLineCap::Round: return "round";
+    case RNMapsPolylineLineCap::Square: return "square";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsPolylineLineCap &value) {
+  return toString(value);
+}
+#endif
+enum class RNMapsPolylineLineJoin { Miter, Round, Bevel };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsPolylineLineJoin &result) {
+  auto string = (std::string)value;
+  if (string == "miter") { result = RNMapsPolylineLineJoin::Miter; return; }
+  if (string == "round") { result = RNMapsPolylineLineJoin::Round; return; }
+  if (string == "bevel") { result = RNMapsPolylineLineJoin::Bevel; return; }
+  abort();
+}
+
+static inline std::string toString(const RNMapsPolylineLineJoin &value) {
+  switch (value) {
+    case RNMapsPolylineLineJoin::Miter: return "miter";
+    case RNMapsPolylineLineJoin::Round: return "round";
+    case RNMapsPolylineLineJoin::Bevel: return "bevel";
+  }
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsPolylineLineJoin &value) {
+  return toString(value);
+}
+#endif
+struct RNMapsPolylineCoordinatesStruct {
+  double latitude{0.0};
+  double longitude{0.0};
+
+#ifdef RN_SERIALIZABLE_STATE
+  bool operator==(const RNMapsPolylineCoordinatesStruct&) const = default;
+
+  folly::dynamic toDynamic() const {
+    folly::dynamic result = folly::dynamic::object();
+    result["latitude"] = latitude;
+    result["longitude"] = longitude;
+    return result;
+  }
+#endif
+};
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNMapsPolylineCoordinatesStruct &result) {
+  auto map = (std::unordered_map<std::string, RawValue>)value;
+
+  auto tmp_latitude = map.find("latitude");
+  if (tmp_latitude != map.end()) {
+    fromRawValue(context, tmp_latitude->second, result.latitude);
+  }
+  auto tmp_longitude = map.find("longitude");
+  if (tmp_longitude != map.end()) {
+    fromRawValue(context, tmp_longitude->second, result.longitude);
+  }
+}
+
+static inline std::string toString(const RNMapsPolylineCoordinatesStruct &value) {
+  return "[Object RNMapsPolylineCoordinatesStruct]";
+}
+
+#ifdef RN_SERIALIZABLE_STATE
+static inline folly::dynamic toDynamic(const RNMapsPolylineCoordinatesStruct &value) {
+  return value.toDynamic();
+}
+#endif
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNMapsPolylineCoordinatesStruct> &result) {
+  auto items = (std::vector<RawValue>)value;
+  for (const auto &item : items) {
+    RNMapsPolylineCoordinatesStruct newItem;
+    fromRawValue(context, item, newItem);
+    result.emplace_back(newItem);
+  }
+}
+
+class RNMapsPolylineProps final : public ViewProps {
+ public:
+  RNMapsPolylineProps() = default;
+  RNMapsPolylineProps(const PropsParserContext& context, const RNMapsPolylineProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  std::vector<RNMapsPolylineCoordinatesStruct> coordinates{};
+  bool geodesic{false};
+  RNMapsPolylineLineCap lineCap{RNMapsPolylineLineCap::Butt};
+  std::vector<double> lineDashPattern{};
+  RNMapsPolylineLineJoin lineJoin{RNMapsPolylineLineJoin::Miter};
+  SharedColor strokeColor{};
+  std::vector<SharedColor> strokeColors{};
+  Float strokeWidth{1.0};
+  bool tappable{false};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+class RNMapsUrlTileProps final : public ViewProps {
+ public:
+  RNMapsUrlTileProps() = default;
+  RNMapsUrlTileProps(const PropsParserContext& context, const RNMapsUrlTileProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  bool doubleTileSize{false};
+  bool flipY{false};
+  int maximumNativeZ{100};
+  int maximumZ{100};
+  int minimumZ{0};
+  bool offlineMode{false};
+  bool shouldReplaceMapContent{false};
+  int tileCacheMaxAge{0};
+  std::string tileCachePath{};
+  int tileSize{256};
+  std::string urlTemplate{};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+class RNMapsWMSTileProps final : public ViewProps {
+ public:
+  RNMapsWMSTileProps() = default;
+  RNMapsWMSTileProps(const PropsParserContext& context, const RNMapsWMSTileProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  int maximumNativeZ{100};
+  int maximumZ{100};
+  int minimumZ{0};
+  bool offlineMode{false};
+  bool shouldReplaceMapContent{false};
+  int tileCacheMaxAge{0};
+  std::string tileCachePath{};
+  int tileSize{256};
+  std::string urlTemplate{};
+
+  #ifdef RN_SERIALIZABLE_STATE
+  ComponentName getDiffPropsImplementationTarget() const override;
+
+  folly::dynamic getDiffProps(const Props* prevProps) const override;
+  #endif
+};
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/RNMapsSpecsJSI-generated.cpp b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/RNMapsSpecsJSI-generated.cpp
new file mode 100644
index 0000000..245ce34
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/RNMapsSpecsJSI-generated.cpp
@@ -0,0 +1,74 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleCpp.js
+ */
+
+#include "RNMapsSpecsJSI.h"
+
+namespace facebook::react {
+
+static jsi::Value __hostFunction_NativeAirMapsModuleCxxSpecJSI_getCamera(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeAirMapsModuleCxxSpecJSI *>(&turboModule)->getCamera(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeAirMapsModuleCxxSpecJSI_getMarkersFrames(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeAirMapsModuleCxxSpecJSI *>(&turboModule)->getMarkersFrames(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool()
+  );
+}
+static jsi::Value __hostFunction_NativeAirMapsModuleCxxSpecJSI_getMapBoundaries(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeAirMapsModuleCxxSpecJSI *>(&turboModule)->getMapBoundaries(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeAirMapsModuleCxxSpecJSI_takeSnapshot(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeAirMapsModuleCxxSpecJSI *>(&turboModule)->takeSnapshot(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeAirMapsModuleCxxSpecJSI_getAddressFromCoordinates(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeAirMapsModuleCxxSpecJSI *>(&turboModule)->getAddressFromCoordinates(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeAirMapsModuleCxxSpecJSI_getPointForCoordinate(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeAirMapsModuleCxxSpecJSI *>(&turboModule)->getPointForCoordinate(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeAirMapsModuleCxxSpecJSI_getCoordinateForPoint(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeAirMapsModuleCxxSpecJSI *>(&turboModule)->getCoordinateForPoint(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+
+NativeAirMapsModuleCxxSpecJSI::NativeAirMapsModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RNMapsAirModule", jsInvoker) {
+  methodMap_["getCamera"] = MethodMetadata {1, __hostFunction_NativeAirMapsModuleCxxSpecJSI_getCamera};
+  methodMap_["getMarkersFrames"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleCxxSpecJSI_getMarkersFrames};
+  methodMap_["getMapBoundaries"] = MethodMetadata {1, __hostFunction_NativeAirMapsModuleCxxSpecJSI_getMapBoundaries};
+  methodMap_["takeSnapshot"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleCxxSpecJSI_takeSnapshot};
+  methodMap_["getAddressFromCoordinates"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleCxxSpecJSI_getAddressFromCoordinates};
+  methodMap_["getPointForCoordinate"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleCxxSpecJSI_getPointForCoordinate};
+  methodMap_["getCoordinateForPoint"] = MethodMetadata {2, __hostFunction_NativeAirMapsModuleCxxSpecJSI_getCoordinateForPoint};
+}
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/RNMapsSpecsJSI.h b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/RNMapsSpecsJSI.h
new file mode 100644
index 0000000..8e134d7
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/RNMapsSpecsJSI.h
@@ -0,0 +1,268 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/TurboModule.h>
+#include <react/bridging/Bridging.h>
+
+namespace facebook::react {
+
+
+  
+#pragma mark - NativeAirMapsModuleLatLng
+
+template <typename P0, typename P1>
+struct NativeAirMapsModuleLatLng {
+  P0 latitude;
+  P1 longitude;
+  bool operator==(const NativeAirMapsModuleLatLng &other) const {
+    return latitude == other.latitude && longitude == other.longitude;
+  }
+};
+
+template <typename T>
+struct NativeAirMapsModuleLatLngBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.latitude)>(rt, value.getProperty(rt, "latitude"), jsInvoker),
+      bridging::fromJs<decltype(types.longitude)>(rt, value.getProperty(rt, "longitude"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double latitudeToJs(jsi::Runtime &rt, decltype(types.latitude) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double longitudeToJs(jsi::Runtime &rt, decltype(types.longitude) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "latitude", bridging::toJs(rt, value.latitude, jsInvoker));
+    result.setProperty(rt, "longitude", bridging::toJs(rt, value.longitude, jsInvoker));
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeAirMapsModuleMapBoundaries
+
+template <typename P0, typename P1>
+struct NativeAirMapsModuleMapBoundaries {
+  P0 northEast;
+  P1 southWest;
+  bool operator==(const NativeAirMapsModuleMapBoundaries &other) const {
+    return northEast == other.northEast && southWest == other.southWest;
+  }
+};
+
+template <typename T>
+struct NativeAirMapsModuleMapBoundariesBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.northEast)>(rt, value.getProperty(rt, "northEast"), jsInvoker),
+      bridging::fromJs<decltype(types.southWest)>(rt, value.getProperty(rt, "southWest"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::Object northEastToJs(jsi::Runtime &rt, decltype(types.northEast) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Object southWestToJs(jsi::Runtime &rt, decltype(types.southWest) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "northEast", bridging::toJs(rt, value.northEast, jsInvoker));
+    result.setProperty(rt, "southWest", bridging::toJs(rt, value.southWest, jsInvoker));
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeAirMapsModulePoint
+
+template <typename P0, typename P1>
+struct NativeAirMapsModulePoint {
+  P0 x;
+  P1 y;
+  bool operator==(const NativeAirMapsModulePoint &other) const {
+    return x == other.x && y == other.y;
+  }
+};
+
+template <typename T>
+struct NativeAirMapsModulePointBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.x)>(rt, value.getProperty(rt, "x"), jsInvoker),
+      bridging::fromJs<decltype(types.y)>(rt, value.getProperty(rt, "y"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double xToJs(jsi::Runtime &rt, decltype(types.x) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double yToJs(jsi::Runtime &rt, decltype(types.y) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "x", bridging::toJs(rt, value.x, jsInvoker));
+    result.setProperty(rt, "y", bridging::toJs(rt, value.y, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeAirMapsModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeAirMapsModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value getCamera(jsi::Runtime &rt, double tag) = 0;
+  virtual jsi::Value getMarkersFrames(jsi::Runtime &rt, double tag, bool onlyVisible) = 0;
+  virtual jsi::Value getMapBoundaries(jsi::Runtime &rt, double tag) = 0;
+  virtual jsi::Value takeSnapshot(jsi::Runtime &rt, double tag, jsi::String config) = 0;
+  virtual jsi::Value getAddressFromCoordinates(jsi::Runtime &rt, double tag, jsi::Object coordinate) = 0;
+  virtual jsi::Value getPointForCoordinate(jsi::Runtime &rt, double tag, jsi::Object coordinate) = 0;
+  virtual jsi::Value getCoordinateForPoint(jsi::Runtime &rt, double tag, jsi::Object point) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeAirMapsModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RNMapsAirModule";
+
+protected:
+  NativeAirMapsModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeAirMapsModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeAirMapsModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeAirMapsModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value getCamera(jsi::Runtime &rt, double tag) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCamera) == 2,
+          "Expected getCamera(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getCamera, jsInvoker_, instance_, std::move(tag));
+    }
+    jsi::Value getMarkersFrames(jsi::Runtime &rt, double tag, bool onlyVisible) override {
+      static_assert(
+          bridging::getParameterCount(&T::getMarkersFrames) == 3,
+          "Expected getMarkersFrames(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getMarkersFrames, jsInvoker_, instance_, std::move(tag), std::move(onlyVisible));
+    }
+    jsi::Value getMapBoundaries(jsi::Runtime &rt, double tag) override {
+      static_assert(
+          bridging::getParameterCount(&T::getMapBoundaries) == 2,
+          "Expected getMapBoundaries(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getMapBoundaries, jsInvoker_, instance_, std::move(tag));
+    }
+    jsi::Value takeSnapshot(jsi::Runtime &rt, double tag, jsi::String config) override {
+      static_assert(
+          bridging::getParameterCount(&T::takeSnapshot) == 3,
+          "Expected takeSnapshot(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::takeSnapshot, jsInvoker_, instance_, std::move(tag), std::move(config));
+    }
+    jsi::Value getAddressFromCoordinates(jsi::Runtime &rt, double tag, jsi::Object coordinate) override {
+      static_assert(
+          bridging::getParameterCount(&T::getAddressFromCoordinates) == 3,
+          "Expected getAddressFromCoordinates(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getAddressFromCoordinates, jsInvoker_, instance_, std::move(tag), std::move(coordinate));
+    }
+    jsi::Value getPointForCoordinate(jsi::Runtime &rt, double tag, jsi::Object coordinate) override {
+      static_assert(
+          bridging::getParameterCount(&T::getPointForCoordinate) == 3,
+          "Expected getPointForCoordinate(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getPointForCoordinate, jsInvoker_, instance_, std::move(tag), std::move(coordinate));
+    }
+    jsi::Value getCoordinateForPoint(jsi::Runtime &rt, double tag, jsi::Object point) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCoordinateForPoint) == 3,
+          "Expected getCoordinateForPoint(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getCoordinateForPoint, jsInvoker_, instance_, std::move(tag), std::move(point));
+    }
+
+  private:
+    friend class NativeAirMapsModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ShadowNodes.cpp b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ShadowNodes.cpp
new file mode 100644
index 0000000..5b039ba
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ShadowNodes.cpp
@@ -0,0 +1,26 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeCpp.js
+ */
+
+#include "ShadowNodes.h"
+
+namespace facebook::react {
+
+extern const char RNMapsCalloutComponentName[] = "RNMapsCallout";
+extern const char RNMapsCircleComponentName[] = "RNMapsCircle";
+extern const char RNMapsGoogleMapViewComponentName[] = "RNMapsGoogleMapView";
+extern const char RNMapsGooglePolygonComponentName[] = "RNMapsGooglePolygon";
+extern const char RNMapsMapViewComponentName[] = "RNMapsMapView";
+extern const char RNMapsMarkerComponentName[] = "RNMapsMarker";
+extern const char RNMapsOverlayComponentName[] = "RNMapsOverlay";
+extern const char RNMapsPolylineComponentName[] = "RNMapsPolyline";
+extern const char RNMapsUrlTileComponentName[] = "RNMapsUrlTile";
+extern const char RNMapsWMSTileComponentName[] = "RNMapsWMSTile";
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ShadowNodes.h b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ShadowNodes.h
new file mode 100644
index 0000000..8e13f22
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/ShadowNodes.h
@@ -0,0 +1,131 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeH.js
+ */
+
+#pragma once
+
+#include "EventEmitters.h"
+#include "Props.h"
+#include "States.h"
+#include <react/renderer/components/view/ConcreteViewShadowNode.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+JSI_EXPORT extern const char RNMapsCalloutComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsCallout> component.
+ */
+using RNMapsCalloutShadowNode = ConcreteViewShadowNode<
+    RNMapsCalloutComponentName,
+    RNMapsCalloutProps,
+    RNMapsCalloutEventEmitter,
+    RNMapsCalloutState>;
+
+JSI_EXPORT extern const char RNMapsCircleComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsCircle> component.
+ */
+using RNMapsCircleShadowNode = ConcreteViewShadowNode<
+    RNMapsCircleComponentName,
+    RNMapsCircleProps,
+    RNMapsCircleEventEmitter,
+    RNMapsCircleState>;
+
+JSI_EXPORT extern const char RNMapsGoogleMapViewComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsGoogleMapView> component.
+ */
+using RNMapsGoogleMapViewShadowNode = ConcreteViewShadowNode<
+    RNMapsGoogleMapViewComponentName,
+    RNMapsGoogleMapViewProps,
+    RNMapsGoogleMapViewEventEmitter,
+    RNMapsGoogleMapViewState>;
+
+JSI_EXPORT extern const char RNMapsGooglePolygonComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsGooglePolygon> component.
+ */
+using RNMapsGooglePolygonShadowNode = ConcreteViewShadowNode<
+    RNMapsGooglePolygonComponentName,
+    RNMapsGooglePolygonProps,
+    RNMapsGooglePolygonEventEmitter,
+    RNMapsGooglePolygonState>;
+
+JSI_EXPORT extern const char RNMapsMapViewComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsMapView> component.
+ */
+using RNMapsMapViewShadowNode = ConcreteViewShadowNode<
+    RNMapsMapViewComponentName,
+    RNMapsMapViewProps,
+    RNMapsMapViewEventEmitter,
+    RNMapsMapViewState>;
+
+JSI_EXPORT extern const char RNMapsMarkerComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsMarker> component.
+ */
+using RNMapsMarkerShadowNode = ConcreteViewShadowNode<
+    RNMapsMarkerComponentName,
+    RNMapsMarkerProps,
+    RNMapsMarkerEventEmitter,
+    RNMapsMarkerState>;
+
+JSI_EXPORT extern const char RNMapsOverlayComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsOverlay> component.
+ */
+using RNMapsOverlayShadowNode = ConcreteViewShadowNode<
+    RNMapsOverlayComponentName,
+    RNMapsOverlayProps,
+    RNMapsOverlayEventEmitter,
+    RNMapsOverlayState>;
+
+JSI_EXPORT extern const char RNMapsPolylineComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsPolyline> component.
+ */
+using RNMapsPolylineShadowNode = ConcreteViewShadowNode<
+    RNMapsPolylineComponentName,
+    RNMapsPolylineProps,
+    RNMapsPolylineEventEmitter,
+    RNMapsPolylineState>;
+
+JSI_EXPORT extern const char RNMapsUrlTileComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsUrlTile> component.
+ */
+using RNMapsUrlTileShadowNode = ConcreteViewShadowNode<
+    RNMapsUrlTileComponentName,
+    RNMapsUrlTileProps,
+    RNMapsUrlTileEventEmitter,
+    RNMapsUrlTileState>;
+
+JSI_EXPORT extern const char RNMapsWMSTileComponentName[];
+
+/*
+ * `ShadowNode` for <RNMapsWMSTile> component.
+ */
+using RNMapsWMSTileShadowNode = ConcreteViewShadowNode<
+    RNMapsWMSTileComponentName,
+    RNMapsWMSTileProps,
+    RNMapsWMSTileEventEmitter,
+    RNMapsWMSTileState>;
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/States.cpp b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/States.cpp
new file mode 100644
index 0000000..1dbb184
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/States.cpp
@@ -0,0 +1,16 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateCpp.js
+ */
+#include "States.h"
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/States.h b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/States.h
new file mode 100644
index 0000000..d2c0329
--- /dev/null
+++ b/node_modules/react-native-maps/android/bin/src/main/jni/react/renderer/components/RNMapsSpecs/States.h
@@ -0,0 +1,38 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateH.js
+ */
+#pragma once
+
+#include <react/renderer/core/StateData.h>
+#ifdef RN_SERIALIZABLE_STATE
+#include <folly/dynamic.h>
+#endif
+
+namespace facebook::react {
+
+using RNMapsCalloutState = StateData;
+
+using RNMapsCircleState = StateData;
+
+using RNMapsGoogleMapViewState = StateData;
+
+using RNMapsGooglePolygonState = StateData;
+
+using RNMapsMapViewState = StateData;
+
+using RNMapsMarkerState = StateData;
+
+using RNMapsOverlayState = StateData;
+
+using RNMapsPolylineState = StateData;
+
+using RNMapsUrlTileState = StateData;
+
+using RNMapsWMSTileState = StateData;
+
+} // namespace facebook::react
\ No newline at end of file
diff --git a/node_modules/react-native-maps/android/src/main/jni/CMakeLists.txt b/node_modules/react-native-maps/android/src/main/jni/CMakeLists.txt
index ddb85f5..1895da4 100644
--- a/node_modules/react-native-maps/android/src/main/jni/CMakeLists.txt
+++ b/node_modules/react-native-maps/android/src/main/jni/CMakeLists.txt
@@ -25,4 +25,15 @@ target_link_libraries(
   reactnative
 )
 
-target_compile_reactnative_options(react_codegen_RNMapsSpecs PRIVATE)
+# Apply React Native compile options manually
+target_compile_options(react_codegen_RNMapsSpecs
+  PRIVATE
+    -Wall
+    -Werror
+    -Wno-error=cpp
+    -fexceptions
+    -frtti
+    -std=c++20
+    -DLOG_TAG=\"ReactNative\"
+    -DFOLLY_NO_CONFIG=1
+)
